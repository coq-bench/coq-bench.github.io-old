<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Coq bench</title>
    <link rel="shortcut icon" type="image/png" href="../../../../../favicon.png" />
    <link href="../../../../../bootstrap.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="../../../../../moment.min.js"></script>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../../../../.."><i class="fa fa-lg fa-flag-checkered"></i> Coq bench</a>
          </div>
          <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
              <li><a href="../../..">Unstable</a></li>
              <li><a href=".">8.4.dev / contrib:fsets 8.4.dev</a></li>
              <li class="active"><a href="">2014-11-20 13:31:52</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="../../../../../about.html">About</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="article">
        <div class="row">
          <div class="col-md-12">
            <a href=".">Â« Up</a>
            <h1>
              contrib:fsets
              <small>
                8.4.dev
                <span class="label label-success">3 m 4 s</span>
              </small>
            </h1>
            <p><em><script>document.write(moment("2014-11-20 13:31:52 +0000", "YYYY-MM-DD HH:mm:ss Z").fromNow());</script> (2014-11-20 13:31:52 UTC)</em><p>
            <h2>Lint</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>ruby lint.rb unstable ../unstable/packages/coq:contrib:fsets/coq:contrib:fsets.8.4.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>0 s</dd>
              <dt>Output</dt>
              <dd><pre>The package is valid.
</pre></dd>
            </dl>
            <h2>Dry install</h2>
            <p>Dry install with the current Coq version:</p>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam install -y --dry-run coq:contrib:fsets.8.4.dev coq.8.4.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>1 s</dd>
              <dt>Output</dt>
              <dd><pre>[NOTE] Package coq is already installed (current version is 8.4.dev).
The following actions will be performed:
 - install   coq:contrib:fsets.8.4.dev
=== 1 to install ===
=-=- Synchronizing package archives -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=- Installing packages =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Building coq:contrib:fsets.8.4.dev:
  coq_makefile -f Make -o Makefile
  make -j4
  make install
Installing coq:contrib:fsets.8.4.dev.
</pre></dd>
            </dl>
            <p>Dry install without Coq, to test if the problem was incompatibility with the current Coq version:</p>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>true</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>0 s</dd>
            </dl>
            <h2>Install dependencies</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam install -y --deps-only coq:contrib:fsets.8.4.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>1 s</dd>
            </dl>
            <h2>Install</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam install -y --verbose coq:contrib:fsets.8.4.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>3 m 4 s</dd>
              <dt>Output</dt>
              <dd><pre>The following actions will be performed:
 - install   coq:contrib:fsets.8.4.dev
=== 1 to install ===
=-=- Synchronizing package archives -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[coq:contrib:fsets] Fetching git://clarus.io/fsets#v8.4
Initialized empty Git repository in /home/bench/.opam/packages.dev/coq:contrib:fsets.8.4.dev/.git/
[master (root-commit) 71966e2] opam-git-init
warning: no common commits
From git://clarus.io/fsets
 * [new branch]      v8.4       -&gt; opam-ref
 * [new branch]      v8.4       -&gt; origin/v8.4
.cvsignore
.gitignore
FMapListEq.v
FSetAVL0.v
FSetAVL_dep.v
FSetAVL_prog.v
FSetAVL_test.v
FSetFullAVL.v
FSetList0.v
FSetListEq.v
FSetRBT.v
LICENSE
MOSTLY_MOVED_TO_COQ_STDLIB
MSetAVL_test.v
MSetFullAVL.v
Make
Makefile
MapFunction.v
MultiSets.v
MultiSetsEq.v
PowerSet.v
PrecedenceGraph/.cvsignore
PrecedenceGraph/PrecedenceGraph.v
PrecedenceGraph/README
UsualFacts.v
bench.log
demo.v
demo_msets.v
description
extract.v
HEAD is now at 4030025 FSets: Int.t instead of Int.int after coq commit 16090
=-=- Installing packages =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Building coq:contrib:fsets.8.4.dev:
  coq_makefile -f Make -o Makefile
  make -j4
  make install
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetList0.v&quot; &gt; &quot;FSetList0.v.d&quot; || ( RV=$?; rm -f &quot;FSetList0.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetAVL0.v&quot; &gt; &quot;FSetAVL0.v.d&quot; || ( RV=$?; rm -f &quot;FSetAVL0.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetFullAVL.v&quot; &gt; &quot;FSetFullAVL.v.d&quot; || ( RV=$?; rm -f &quot;FSetFullAVL.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetRBT.v&quot; &gt; &quot;FSetRBT.v.d&quot; || ( RV=$?; rm -f &quot;FSetRBT.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetAVL_dep.v&quot; &gt; &quot;FSetAVL_dep.v.d&quot; || ( RV=$?; rm -f &quot;FSetAVL_dep.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetAVL_prog.v&quot; &gt; &quot;FSetAVL_prog.v.d&quot; || ( RV=$?; rm -f &quot;FSetAVL_prog.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetAVL_test.v&quot; &gt; &quot;FSetAVL_test.v.d&quot; || ( RV=$?; rm -f &quot;FSetAVL_test.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;extract.v&quot; &gt; &quot;extract.v.d&quot; || ( RV=$?; rm -f &quot;extract.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;PrecedenceGraph/PrecedenceGraph.v&quot; &gt; &quot;PrecedenceGraph/PrecedenceGraph.v.d&quot; || ( RV=$?; rm -f &quot;PrecedenceGraph/PrecedenceGraph.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;UsualFacts.v&quot; &gt; &quot;UsualFacts.v.d&quot; || ( RV=$?; rm -f &quot;UsualFacts.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;MapFunction.v&quot; &gt; &quot;MapFunction.v.d&quot; || ( RV=$?; rm -f &quot;MapFunction.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;PowerSet.v&quot; &gt; &quot;PowerSet.v.d&quot; || ( RV=$?; rm -f &quot;PowerSet.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FMapListEq.v&quot; &gt; &quot;FMapListEq.v.d&quot; || ( RV=$?; rm -f &quot;FMapListEq.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;FSetListEq.v&quot; &gt; &quot;FSetListEq.v.d&quot; || ( RV=$?; rm -f &quot;FSetListEq.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;MultiSets.v&quot; &gt; &quot;MultiSets.v.d&quot; || ( RV=$?; rm -f &quot;MultiSets.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;MultiSetsEq.v&quot; &gt; &quot;MultiSetsEq.v.d&quot; || ( RV=$?; rm -f &quot;MultiSetsEq.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;demo.v&quot; &gt; &quot;demo.v.d&quot; || ( RV=$?; rm -f &quot;demo.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;demo_msets.v&quot; &gt; &quot;demo_msets.v.d&quot; || ( RV=$?; rm -f &quot;demo_msets.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;MSetAVL_test.v&quot; &gt; &quot;MSetAVL_test.v.d&quot; || ( RV=$?; rm -f &quot;MSetAVL_test.v.d&quot;; exit ${RV} )
&quot;coqdep&quot; -c -slash -R . FSets &quot;MSetFullAVL.v&quot; &gt; &quot;MSetFullAVL.v.d&quot; || ( RV=$?; rm -f &quot;MSetFullAVL.v.d&quot;; exit ${RV} )
&quot;coqc&quot;  -q  -R . FSets   MSetFullAVL
&quot;coqc&quot;  -q  -R . FSets   MSetAVL_test
&quot;coqc&quot;  -q  -R . FSets   demo_msets
&quot;coqc&quot;  -q  -R . FSets   demo
Warning: Extraction inside an opened module is experimental.
In case of problem, close it first.
type &#39;x compare =
| LT
| EQ
| GT
type __ = Obj.t
let __ = let rec f _ = Obj.repr f in Obj.repr f
type bool =
| True
| False
(** val negb : bool -&gt; bool **)
let negb = function
| True -&gt; False
| False -&gt; True
type nat =
| O
| S of nat
type (&#39;a, &#39;b) prod =
| Pair of &#39;a * &#39;b
(** val fst : (&#39;a1, &#39;a2) prod -&gt; &#39;a1 **)
let fst = function
| Pair (x, y) -&gt; x
(** val snd : (&#39;a1, &#39;a2) prod -&gt; &#39;a2 **)
let snd = function
| Pair (x, y) -&gt; y
type comparison =
| Eq
| Lt
| Gt
(** val compOpp : comparison -&gt; comparison **)
let compOpp = function
| Eq -&gt; Eq
| Lt -&gt; Gt
| Gt -&gt; Lt
type compareSpecT =
| CompEqT
| CompLtT
| CompGtT
(** val compareSpec2Type : comparison -&gt; compareSpecT **)
let compareSpec2Type = function
| Eq -&gt; CompEqT
| Lt -&gt; CompLtT
| Gt -&gt; CompGtT
type &#39;a compSpecT = compareSpecT
(** val compSpec2Type : &#39;a1 -&gt; &#39;a1 -&gt; comparison -&gt; &#39;a1 compSpecT **)
let compSpec2Type x y c =
  compareSpec2Type c
type &#39;a sig0 =
  &#39;a
  (* singleton inductive, whose constructor was exist *)
type sumbool =
| Left
| Right
type &#39;a sumor =
| Inleft of &#39;a
| Inright
(** val plus : nat -&gt; nat -&gt; nat **)
let rec plus n0 m =
  match n0 with
  | O -&gt; m
  | S p -&gt; S (plus p m)
(** val nat_iter : nat -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
let rec nat_iter n0 f x =
  match n0 with
  | O -&gt; x
  | S n&#39; -&gt; f (nat_iter n&#39; f x)
type reflect =
| ReflectT
| ReflectF
(** val iff_reflect : bool -&gt; reflect **)
let iff_reflect = function
| True -&gt; ReflectT
| False -&gt; ReflectF
type positive =
| XI of positive
| XO of positive
| XH
type n =
| N0
| Npos of positive
type z =
| Z0
| Zpos of positive
| Zneg of positive
module Pos = 
 struct 
  type t = positive
  (** val succ : positive -&gt; positive **)
  let rec succ = function
  | XI p -&gt; XO (succ p)
  | XO p -&gt; XI p
  | XH -&gt; XO XH
  (** val add : positive -&gt; positive -&gt; positive **)
  let rec add x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XI (add p q)
       | XO q -&gt; XO (add p q)
       | XH -&gt; XI p)
    | XH -&gt;
      (match y with
       | XI q -&gt; XO (succ q)
       | XO q -&gt; XI q
       | XH -&gt; XO XH)
  (** val add_carry : positive -&gt; positive -&gt; positive **)
  and add_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XI (add_carry p q)
       | XO q -&gt; XO (add_carry p q)
       | XH -&gt; XI (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XH -&gt;
      (match y with
       | XI q -&gt; XI (succ q)
       | XO q -&gt; XO (succ q)
       | XH -&gt; XI XH)
  (** val pred_double : positive -&gt; positive **)
  let rec pred_double = function
  | XI p -&gt; XI (XO p)
  | XO p -&gt; XI (pred_double p)
  | XH -&gt; XH
  (** val pred : positive -&gt; positive **)
  let pred = function
  | XI p -&gt; XO p
  | XO p -&gt; pred_double p
  | XH -&gt; XH
  (** val pred_N : positive -&gt; n **)
  let pred_N = function
  | XI p -&gt; Npos (XO p)
  | XO p -&gt; Npos (pred_double p)
  | XH -&gt; N0
  type mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  (** val mask_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rect f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val mask_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rec f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val succ_double_mask : mask -&gt; mask **)
  let succ_double_mask = function
  | IsNul -&gt; IsPos XH
  | IsPos p -&gt; IsPos (XI p)
  | IsNeg -&gt; IsNeg
  (** val double_mask : mask -&gt; mask **)
  let double_mask = function
  | IsPos p -&gt; IsPos (XO p)
  | x0 -&gt; x0
  (** val double_pred_mask : positive -&gt; mask **)
  let double_pred_mask = function
  | XI p -&gt; IsPos (XO (XO p))
  | XO p -&gt; IsPos (XO (pred_double p))
  | XH -&gt; IsNul
  (** val pred_mask : mask -&gt; mask **)
  let pred_mask = function
  | IsPos q -&gt;
    (match q with
     | XH -&gt; IsNul
     | _ -&gt; IsPos (pred q))
  | _ -&gt; IsNeg
  (** val sub_mask : positive -&gt; positive -&gt; mask **)
  let rec sub_mask x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask p q)
       | XO q -&gt; succ_double_mask (sub_mask p q)
       | XH -&gt; IsPos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XH -&gt;
      (match y with
       | XH -&gt; IsNul
       | _ -&gt; IsNeg)
  (** val sub_mask_carry : positive -&gt; positive -&gt; mask **)
  and sub_mask_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask_carry p q)
       | XO q -&gt; succ_double_mask (sub_mask_carry p q)
       | XH -&gt; double_pred_mask p)
    | XH -&gt; IsNeg
  (** val sub : positive -&gt; positive -&gt; positive **)
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -&gt; z0
    | _ -&gt; XH
  (** val mul : positive -&gt; positive -&gt; positive **)
  let rec mul x y =
    match x with
    | XI p -&gt; add y (XO (mul p y))
    | XO p -&gt; XO (mul p y)
    | XH -&gt; y
  (** val iter : positive -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter n0 f x =
    match n0 with
    | XI n&#39; -&gt; f (iter n&#39; f (iter n&#39; f x))
    | XO n&#39; -&gt; iter n&#39; f (iter n&#39; f x)
    | XH -&gt; f x
  (** val pow : positive -&gt; positive -&gt; positive **)
  let pow x y =
    iter y (mul x) XH
  (** val square : positive -&gt; positive **)
  let rec square = function
  | XI p0 -&gt; XI (XO (add (square p0) p0))
  | XO p0 -&gt; XO (XO (square p0))
  | XH -&gt; XH
  (** val div2 : positive -&gt; positive **)
  let div2 = function
  | XI p0 -&gt; p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val div2_up : positive -&gt; positive **)
  let div2_up = function
  | XI p0 -&gt; succ p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val size_nat : positive -&gt; nat **)
  let rec size_nat = function
  | XI p0 -&gt; S (size_nat p0)
  | XO p0 -&gt; S (size_nat p0)
  | XH -&gt; S O
  (** val size : positive -&gt; positive **)
  let rec size = function
  | XI p0 -&gt; succ (size p0)
  | XO p0 -&gt; succ (size p0)
  | XH -&gt; XH
  (** val compare_cont : positive -&gt; positive -&gt; comparison -&gt; comparison **)
  let rec compare_cont x y r =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q r
       | XO q -&gt; compare_cont p q Gt
       | XH -&gt; Gt)
    | XO p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q Lt
       | XO q -&gt; compare_cont p q r
       | XH -&gt; Gt)
    | XH -&gt;
      (match y with
       | XH -&gt; r
       | _ -&gt; Lt)
  (** val compare : positive -&gt; positive -&gt; comparison **)
  let compare x y =
    compare_cont x y Eq
  (** val min : positive -&gt; positive -&gt; positive **)
  let min p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p&#39;
    | _ -&gt; p
  (** val max : positive -&gt; positive -&gt; positive **)
  let max p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p
    | _ -&gt; p&#39;
  (** val eqb : positive -&gt; positive -&gt; bool **)
  let rec eqb p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XO p0 -&gt;
      (match q with
       | XO q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XH -&gt;
      (match q with
       | XH -&gt; True
       | _ -&gt; False)
  (** val leb : positive -&gt; positive -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : positive -&gt; positive -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val sqrtrem_step :
      (positive -&gt; positive) -&gt; (positive -&gt; positive) -&gt; (positive, mask)
      prod -&gt; (positive, mask) prod **)
  let sqrtrem_step f g = function
  | Pair (s, y) -&gt;
    (match y with
     | IsPos r -&gt;
       let s&#39; = XI (XO s) in
       let r&#39; = g (f r) in
       (match leb s&#39; r&#39; with
        | True -&gt; Pair ((XI s), (sub_mask r&#39; s&#39;))
        | False -&gt; Pair ((XO s), (IsPos r&#39;)))
     | _ -&gt; Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  (** val sqrtrem : positive -&gt; (positive, mask) prod **)
  let rec sqrtrem = function
  | XI p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XI x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XI x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos (XO XH))))
  | XO p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XO x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XO x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos XH)))
  | XH -&gt; Pair (XH, IsNul)
  (** val sqrt : positive -&gt; positive **)
  let sqrt p =
    fst (sqrtrem p)
  (** val gcdn : nat -&gt; positive -&gt; positive -&gt; positive **)
  let rec gcdn n0 a b =
    match n0 with
    | O -&gt; XH
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; a
             | Lt -&gt; gcdn n1 (sub b&#39; a&#39;) a
             | Gt -&gt; gcdn n1 (sub a&#39; b&#39;) b)
          | XO b0 -&gt; gcdn n1 a b0
          | XH -&gt; XH)
       | XO a0 -&gt;
         (match b with
          | XI p -&gt; gcdn n1 a0 b
          | XO b0 -&gt; XO (gcdn n1 a0 b0)
          | XH -&gt; XH)
       | XH -&gt; XH)
  (** val gcd : positive -&gt; positive -&gt; positive **)
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  (** val ggcdn :
      nat -&gt; positive -&gt; positive -&gt; (positive, (positive, positive) prod)
      prod **)
  let rec ggcdn n0 a b =
    match n0 with
    | O -&gt; Pair (XH, (Pair (a, b)))
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; Pair (a, (Pair (XH, XH)))
             | Lt -&gt;
               let Pair (g, p) = ggcdn n1 (sub b&#39; a&#39;) a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt -&gt;
               let Pair (g, p) = ggcdn n1 (sub a&#39; b&#39;) b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 -&gt;
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XO a0 -&gt;
         (match b with
          | XI p -&gt;
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -&gt; let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XH -&gt; Pair (XH, (Pair (XH, b))))
  (** val ggcd :
      positive -&gt; positive -&gt; (positive, (positive, positive) prod) prod **)
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  (** val coq_Nsucc_double : n -&gt; n **)
  let coq_Nsucc_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val coq_Ndouble : n -&gt; n **)
  let coq_Ndouble = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val coq_lor : positive -&gt; positive -&gt; positive **)
  let rec coq_lor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XI (coq_lor p0 q0)
       | XH -&gt; p)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XO (coq_lor p0 q0)
       | XH -&gt; XI p0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; XI q0
       | _ -&gt; q)
  (** val coq_land : positive -&gt; positive -&gt; n **)
  let rec coq_land p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; Npos XH)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; N0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; N0
       | _ -&gt; Npos XH)
  (** val ldiff : positive -&gt; positive -&gt; n **)
  let rec ldiff p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (ldiff p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XH -&gt; Npos p)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; Npos XH
       | _ -&gt; N0)
  (** val coq_lxor : positive -&gt; positive -&gt; n **)
  let rec coq_lxor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XH -&gt; Npos (XI p0))
    | XH -&gt;
      (match q with
       | XI q0 -&gt; Npos (XO q0)
       | XO q0 -&gt; Npos (XI q0)
       | XH -&gt; N0)
  (** val shiftl_nat : positive -&gt; nat -&gt; positive **)
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -&gt; XO x) p
  (** val shiftr_nat : positive -&gt; nat -&gt; positive **)
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  (** val shiftl : positive -&gt; n -&gt; positive **)
  let shiftl p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 (fun x -&gt; XO x) p
  (** val shiftr : positive -&gt; n -&gt; positive **)
  let shiftr p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 div2 p
  (** val testbit_nat : positive -&gt; nat -&gt; bool **)
  let rec testbit_nat p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | O -&gt; True
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XO p0 -&gt;
      (match n0 with
       | O -&gt; False
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XH -&gt;
      (match n0 with
       | O -&gt; True
       | S n1 -&gt; False)
  (** val testbit : positive -&gt; n -&gt; bool **)
  let rec testbit p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XO p0 -&gt;
      (match n0 with
       | N0 -&gt; False
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XH -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos p0 -&gt; False)
  (** val iter_op : (&#39;a1 -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter_op op p a =
    match p with
    | XI p0 -&gt; op a (iter_op op p0 (op a a))
    | XO p0 -&gt; iter_op op p0 (op a a)
    | XH -&gt; a
  (** val to_nat : positive -&gt; nat **)
  let to_nat x =
    iter_op plus x (S O)
  (** val of_nat : nat -&gt; positive **)
  let rec of_nat = function
  | O -&gt; XH
  | S x -&gt;
    (match x with
     | O -&gt; XH
     | S n1 -&gt; succ (of_nat x))
  (** val of_succ_nat : nat -&gt; positive **)
  let rec of_succ_nat = function
  | O -&gt; XH
  | S x -&gt; succ (of_succ_nat x)
 end
module Coq_Pos = 
 struct 
  type t = positive
  (** val succ : positive -&gt; positive **)
  let rec succ = function
  | XI p -&gt; XO (succ p)
  | XO p -&gt; XI p
  | XH -&gt; XO XH
  (** val add : positive -&gt; positive -&gt; positive **)
  let rec add x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XI (add p q)
       | XO q -&gt; XO (add p q)
       | XH -&gt; XI p)
    | XH -&gt;
      (match y with
       | XI q -&gt; XO (succ q)
       | XO q -&gt; XI q
       | XH -&gt; XO XH)
  (** val add_carry : positive -&gt; positive -&gt; positive **)
  and add_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XI (add_carry p q)
       | XO q -&gt; XO (add_carry p q)
       | XH -&gt; XI (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XH -&gt;
      (match y with
       | XI q -&gt; XI (succ q)
       | XO q -&gt; XO (succ q)
       | XH -&gt; XI XH)
  (** val pred_double : positive -&gt; positive **)
  let rec pred_double = function
  | XI p -&gt; XI (XO p)
  | XO p -&gt; XI (pred_double p)
  | XH -&gt; XH
  (** val pred : positive -&gt; positive **)
  let pred = function
  | XI p -&gt; XO p
  | XO p -&gt; pred_double p
  | XH -&gt; XH
  (** val pred_N : positive -&gt; n **)
  let pred_N = function
  | XI p -&gt; Npos (XO p)
  | XO p -&gt; Npos (pred_double p)
  | XH -&gt; N0
  type mask = Pos.mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  (** val mask_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rect f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val mask_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rec f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val succ_double_mask : mask -&gt; mask **)
  let succ_double_mask = function
  | IsNul -&gt; IsPos XH
  | IsPos p -&gt; IsPos (XI p)
  | IsNeg -&gt; IsNeg
  (** val double_mask : mask -&gt; mask **)
  let double_mask = function
  | IsPos p -&gt; IsPos (XO p)
  | x0 -&gt; x0
  (** val double_pred_mask : positive -&gt; mask **)
  let double_pred_mask = function
  | XI p -&gt; IsPos (XO (XO p))
  | XO p -&gt; IsPos (XO (pred_double p))
  | XH -&gt; IsNul
  (** val pred_mask : mask -&gt; mask **)
  let pred_mask = function
  | IsPos q -&gt;
    (match q with
     | XH -&gt; IsNul
     | _ -&gt; IsPos (pred q))
  | _ -&gt; IsNeg
  (** val sub_mask : positive -&gt; positive -&gt; mask **)
  let rec sub_mask x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask p q)
       | XO q -&gt; succ_double_mask (sub_mask p q)
       | XH -&gt; IsPos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XH -&gt;
      (match y with
       | XH -&gt; IsNul
       | _ -&gt; IsNeg)
  (** val sub_mask_carry : positive -&gt; positive -&gt; mask **)
  and sub_mask_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask_carry p q)
       | XO q -&gt; succ_double_mask (sub_mask_carry p q)
       | XH -&gt; double_pred_mask p)
    | XH -&gt; IsNeg
  (** val sub : positive -&gt; positive -&gt; positive **)
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -&gt; z0
    | _ -&gt; XH
  (** val mul : positive -&gt; positive -&gt; positive **)
  let rec mul x y =
    match x with
    | XI p -&gt; add y (XO (mul p y))
    | XO p -&gt; XO (mul p y)
    | XH -&gt; y
  (** val iter : positive -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter n0 f x =
    match n0 with
    | XI n&#39; -&gt; f (iter n&#39; f (iter n&#39; f x))
    | XO n&#39; -&gt; iter n&#39; f (iter n&#39; f x)
    | XH -&gt; f x
  (** val pow : positive -&gt; positive -&gt; positive **)
  let pow x y =
    iter y (mul x) XH
  (** val square : positive -&gt; positive **)
  let rec square = function
  | XI p0 -&gt; XI (XO (add (square p0) p0))
  | XO p0 -&gt; XO (XO (square p0))
  | XH -&gt; XH
  (** val div2 : positive -&gt; positive **)
  let div2 = function
  | XI p0 -&gt; p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val div2_up : positive -&gt; positive **)
  let div2_up = function
  | XI p0 -&gt; succ p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val size_nat : positive -&gt; nat **)
  let rec size_nat = function
  | XI p0 -&gt; S (size_nat p0)
  | XO p0 -&gt; S (size_nat p0)
  | XH -&gt; S O
  (** val size : positive -&gt; positive **)
  let rec size = function
  | XI p0 -&gt; succ (size p0)
  | XO p0 -&gt; succ (size p0)
  | XH -&gt; XH
  (** val compare_cont : positive -&gt; positive -&gt; comparison -&gt; comparison **)
  let rec compare_cont x y r =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q r
       | XO q -&gt; compare_cont p q Gt
       | XH -&gt; Gt)
    | XO p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q Lt
       | XO q -&gt; compare_cont p q r
       | XH -&gt; Gt)
    | XH -&gt;
      (match y with
       | XH -&gt; r
       | _ -&gt; Lt)
  (** val compare : positive -&gt; positive -&gt; comparison **)
  let compare x y =
    compare_cont x y Eq
  (** val min : positive -&gt; positive -&gt; positive **)
  let min p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p&#39;
    | _ -&gt; p
  (** val max : positive -&gt; positive -&gt; positive **)
  let max p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p
    | _ -&gt; p&#39;
  (** val eqb : positive -&gt; positive -&gt; bool **)
  let rec eqb p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XO p0 -&gt;
      (match q with
       | XO q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XH -&gt;
      (match q with
       | XH -&gt; True
       | _ -&gt; False)
  (** val leb : positive -&gt; positive -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : positive -&gt; positive -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val sqrtrem_step :
      (positive -&gt; positive) -&gt; (positive -&gt; positive) -&gt; (positive, mask)
      prod -&gt; (positive, mask) prod **)
  let sqrtrem_step f g = function
  | Pair (s, y) -&gt;
    (match y with
     | IsPos r -&gt;
       let s&#39; = XI (XO s) in
       let r&#39; = g (f r) in
       (match leb s&#39; r&#39; with
        | True -&gt; Pair ((XI s), (sub_mask r&#39; s&#39;))
        | False -&gt; Pair ((XO s), (IsPos r&#39;)))
     | _ -&gt; Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  (** val sqrtrem : positive -&gt; (positive, mask) prod **)
  let rec sqrtrem = function
  | XI p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XI x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XI x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos (XO XH))))
  | XO p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XO x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XO x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos XH)))
  | XH -&gt; Pair (XH, IsNul)
  (** val sqrt : positive -&gt; positive **)
  let sqrt p =
    fst (sqrtrem p)
  (** val gcdn : nat -&gt; positive -&gt; positive -&gt; positive **)
  let rec gcdn n0 a b =
    match n0 with
    | O -&gt; XH
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; a
             | Lt -&gt; gcdn n1 (sub b&#39; a&#39;) a
             | Gt -&gt; gcdn n1 (sub a&#39; b&#39;) b)
          | XO b0 -&gt; gcdn n1 a b0
          | XH -&gt; XH)
       | XO a0 -&gt;
         (match b with
          | XI p -&gt; gcdn n1 a0 b
          | XO b0 -&gt; XO (gcdn n1 a0 b0)
          | XH -&gt; XH)
       | XH -&gt; XH)
  (** val gcd : positive -&gt; positive -&gt; positive **)
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  (** val ggcdn :
      nat -&gt; positive -&gt; positive -&gt; (positive, (positive, positive) prod)
      prod **)
  let rec ggcdn n0 a b =
    match n0 with
    | O -&gt; Pair (XH, (Pair (a, b)))
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; Pair (a, (Pair (XH, XH)))
             | Lt -&gt;
               let Pair (g, p) = ggcdn n1 (sub b&#39; a&#39;) a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt -&gt;
               let Pair (g, p) = ggcdn n1 (sub a&#39; b&#39;) b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 -&gt;
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XO a0 -&gt;
         (match b with
          | XI p -&gt;
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -&gt; let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XH -&gt; Pair (XH, (Pair (XH, b))))
  (** val ggcd :
      positive -&gt; positive -&gt; (positive, (positive, positive) prod) prod **)
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  (** val coq_Nsucc_double : n -&gt; n **)
  let coq_Nsucc_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val coq_Ndouble : n -&gt; n **)
  let coq_Ndouble = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val coq_lor : positive -&gt; positive -&gt; positive **)
  let rec coq_lor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XI (coq_lor p0 q0)
       | XH -&gt; p)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XO (coq_lor p0 q0)
       | XH -&gt; XI p0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; XI q0
       | _ -&gt; q)
  (** val coq_land : positive -&gt; positive -&gt; n **)
  let rec coq_land p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; Npos XH)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; N0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; N0
       | _ -&gt; Npos XH)
  (** val ldiff : positive -&gt; positive -&gt; n **)
  let rec ldiff p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (ldiff p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XH -&gt; Npos p)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; Npos XH
       | _ -&gt; N0)
  (** val coq_lxor : positive -&gt; positive -&gt; n **)
  let rec coq_lxor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XH -&gt; Npos (XI p0))
    | XH -&gt;
      (match q with
       | XI q0 -&gt; Npos (XO q0)
       | XO q0 -&gt; Npos (XI q0)
       | XH -&gt; N0)
  (** val shiftl_nat : positive -&gt; nat -&gt; positive **)
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -&gt; XO x) p
  (** val shiftr_nat : positive -&gt; nat -&gt; positive **)
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  (** val shiftl : positive -&gt; n -&gt; positive **)
  let shiftl p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 (fun x -&gt; XO x) p
  (** val shiftr : positive -&gt; n -&gt; positive **)
  let shiftr p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 div2 p
  (** val testbit_nat : positive -&gt; nat -&gt; bool **)
  let rec testbit_nat p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | O -&gt; True
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XO p0 -&gt;
      (match n0 with
       | O -&gt; False
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XH -&gt;
      (match n0 with
       | O -&gt; True
       | S n1 -&gt; False)
  (** val testbit : positive -&gt; n -&gt; bool **)
  let rec testbit p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XO p0 -&gt;
      (match n0 with
       | N0 -&gt; False
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XH -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos p0 -&gt; False)
  (** val iter_op : (&#39;a1 -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter_op op p a =
    match p with
    | XI p0 -&gt; op a (iter_op op p0 (op a a))
    | XO p0 -&gt; iter_op op p0 (op a a)
    | XH -&gt; a
  (** val to_nat : positive -&gt; nat **)
  let to_nat x =
    iter_op plus x (S O)
  (** val of_nat : nat -&gt; positive **)
  let rec of_nat = function
  | O -&gt; XH
  | S x -&gt;
    (match x with
     | O -&gt; XH
     | S n1 -&gt; succ (of_nat x))
  (** val of_succ_nat : nat -&gt; positive **)
  let rec of_succ_nat = function
  | O -&gt; XH
  | S x -&gt; succ (of_succ_nat x)
  (** val eq_dec : positive -&gt; positive -&gt; sumbool **)
  let rec eq_dec p y0 =
    match p with
    | XI p0 -&gt;
      (match y0 with
       | XI p1 -&gt; eq_dec p0 p1
       | _ -&gt; Right)
    | XO p0 -&gt;
      (match y0 with
       | XO p1 -&gt; eq_dec p0 p1
       | _ -&gt; Right)
    | XH -&gt;
      (match y0 with
       | XH -&gt; Left
       | _ -&gt; Right)
  (** val peano_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 **)
  let rec peano_rect a f p =
    let f2 = peano_rect (f XH a) (fun p0 x -&gt; f (succ (XO p0)) (f (XO p0) x))
    in
    (match p with
     | XI q -&gt; f (XO q) (f2 q)
     | XO q -&gt; f2 q
     | XH -&gt; a)
  (** val peano_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 **)
  let peano_rec =
    peano_rect
  type coq_PeanoView =
  | PeanoOne
  | PeanoSucc of positive * coq_PeanoView
  (** val coq_PeanoView_rect :
      &#39;a1 -&gt; (positive -&gt; coq_PeanoView -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt;
      coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_rect f f0 p = function
  | PeanoOne -&gt; f
  | PeanoSucc (p1, p2) -&gt; f0 p1 p2 (coq_PeanoView_rect f f0 p1 p2)
  (** val coq_PeanoView_rec :
      &#39;a1 -&gt; (positive -&gt; coq_PeanoView -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt;
      coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_rec f f0 p = function
  | PeanoOne -&gt; f
  | PeanoSucc (p1, p2) -&gt; f0 p1 p2 (coq_PeanoView_rec f f0 p1 p2)
  (** val peanoView_xO : positive -&gt; coq_PeanoView -&gt; coq_PeanoView **)
  let rec peanoView_xO p = function
  | PeanoOne -&gt; PeanoSucc (XH, PeanoOne)
  | PeanoSucc (p0, q0) -&gt;
    PeanoSucc ((succ (XO p0)), (PeanoSucc ((XO p0), (peanoView_xO p0 q0))))
  (** val peanoView_xI : positive -&gt; coq_PeanoView -&gt; coq_PeanoView **)
  let rec peanoView_xI p = function
  | PeanoOne -&gt; PeanoSucc ((succ XH), (PeanoSucc (XH, PeanoOne)))
  | PeanoSucc (p0, q0) -&gt;
    PeanoSucc ((succ (XI p0)), (PeanoSucc ((XI p0), (peanoView_xI p0 q0))))
  (** val peanoView : positive -&gt; coq_PeanoView **)
  let rec peanoView = function
  | XI p0 -&gt; peanoView_xI p0 (peanoView p0)
  | XO p0 -&gt; peanoView_xO p0 (peanoView p0)
  | XH -&gt; PeanoOne
  (** val coq_PeanoView_iter :
      &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_iter a f p = function
  | PeanoOne -&gt; a
  | PeanoSucc (p0, q0) -&gt; f p0 (coq_PeanoView_iter a f p0 q0)
  (** val eqb_spec : positive -&gt; positive -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val switch_Eq : comparison -&gt; comparison -&gt; comparison **)
  let switch_Eq c = function
  | Eq -&gt; c
  | x -&gt; x
  (** val mask2cmp : mask -&gt; comparison **)
  let mask2cmp = function
  | IsNul -&gt; Eq
  | IsPos p0 -&gt; Gt
  | IsNeg -&gt; Lt
  (** val leb_spec0 : positive -&gt; positive -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : positive -&gt; positive -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : positive -&gt; positive -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : positive -&gt; positive -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong :
      positive -&gt; positive -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : positive -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : positive -&gt; positive -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong :
      positive -&gt; positive -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : positive -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : positive -&gt; positive -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module N = 
 struct 
  type t = n
  (** val zero : n **)
  let zero =
    N0
  (** val one : n **)
  let one =
    Npos XH
  (** val two : n **)
  let two =
    Npos (XO XH)
  (** val succ_double : n -&gt; n **)
  let succ_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val double : n -&gt; n **)
  let double = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val succ : n -&gt; n **)
  let succ = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (Coq_Pos.succ p)
  (** val pred : n -&gt; n **)
  let pred = function
  | N0 -&gt; N0
  | Npos p -&gt; Coq_Pos.pred_N p
  (** val succ_pos : n -&gt; positive **)
  let succ_pos = function
  | N0 -&gt; XH
  | Npos p -&gt; Coq_Pos.succ p
  (** val add : n -&gt; n -&gt; n **)
  let add n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Npos (Coq_Pos.add p q))
  (** val sub : n -&gt; n -&gt; n **)
  let sub n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos n&#39; -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos m&#39; -&gt;
         (match Coq_Pos.sub_mask n&#39; m&#39; with
          | Coq_Pos.IsPos p -&gt; Npos p
          | _ -&gt; N0))
  (** val mul : n -&gt; n -&gt; n **)
  let mul n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; N0
       | Npos q -&gt; Npos (Coq_Pos.mul p q))
  (** val compare : n -&gt; n -&gt; comparison **)
  let compare n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; Eq
       | Npos m&#39; -&gt; Lt)
    | Npos n&#39; -&gt;
      (match m with
       | N0 -&gt; Gt
       | Npos m&#39; -&gt; Coq_Pos.compare n&#39; m&#39;)
  (** val eqb : n -&gt; n -&gt; bool **)
  let rec eqb n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; True
       | Npos p -&gt; False)
    | Npos p -&gt;
      (match m with
       | N0 -&gt; False
       | Npos q -&gt; Coq_Pos.eqb p q)
  (** val leb : n -&gt; n -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : n -&gt; n -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val min : n -&gt; n -&gt; n **)
  let min n0 n&#39; =
    match compare n0 n&#39; with
    | Gt -&gt; n&#39;
    | _ -&gt; n0
  (** val max : n -&gt; n -&gt; n **)
  let max n0 n&#39; =
    match compare n0 n&#39; with
    | Gt -&gt; n0
    | _ -&gt; n&#39;
  (** val div2 : n -&gt; n **)
  let div2 = function
  | N0 -&gt; N0
  | Npos p0 -&gt;
    (match p0 with
     | XI p -&gt; Npos p
     | XO p -&gt; Npos p
     | XH -&gt; N0)
  (** val even : n -&gt; bool **)
  let even = function
  | N0 -&gt; True
  | Npos p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  (** val odd : n -&gt; bool **)
  let odd n0 =
    negb (even n0)
  (** val pow : n -&gt; n -&gt; n **)
  let pow n0 = function
  | N0 -&gt; Npos XH
  | Npos p0 -&gt;
    (match n0 with
     | N0 -&gt; N0
     | Npos q -&gt; Npos (Coq_Pos.pow q p0))
  (** val square : n -&gt; n **)
  let square = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.square p)
  (** val log2 : n -&gt; n **)
  let log2 = function
  | N0 -&gt; N0
  | Npos p0 -&gt;
    (match p0 with
     | XI p -&gt; Npos (Coq_Pos.size p)
     | XO p -&gt; Npos (Coq_Pos.size p)
     | XH -&gt; N0)
  (** val size : n -&gt; n **)
  let size = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.size p)
  (** val size_nat : n -&gt; nat **)
  let size_nat = function
  | N0 -&gt; O
  | Npos p -&gt; Coq_Pos.size_nat p
  (** val pos_div_eucl : positive -&gt; n -&gt; (n, n) prod **)
  let rec pos_div_eucl a b =
    match a with
    | XI a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = succ_double r in
      (match leb b r&#39; with
       | True -&gt; Pair ((succ_double q), (sub r&#39; b))
       | False -&gt; Pair ((double q), r&#39;))
    | XO a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = double r in
      (match leb b r&#39; with
       | True -&gt; Pair ((succ_double q), (sub r&#39; b))
       | False -&gt; Pair ((double q), r&#39;))
    | XH -&gt;
      (match b with
       | N0 -&gt; Pair (N0, (Npos XH))
       | Npos p -&gt;
         (match p with
          | XH -&gt; Pair ((Npos XH), N0)
          | _ -&gt; Pair (N0, (Npos XH))))
  (** val div_eucl : n -&gt; n -&gt; (n, n) prod **)
  let div_eucl a b =
    match a with
    | N0 -&gt; Pair (N0, N0)
    | Npos na -&gt;
      (match b with
       | N0 -&gt; Pair (N0, a)
       | Npos p -&gt; pos_div_eucl na b)
  (** val div : n -&gt; n -&gt; n **)
  let div a b =
    fst (div_eucl a b)
  (** val modulo : n -&gt; n -&gt; n **)
  let modulo a b =
    snd (div_eucl a b)
  (** val gcd : n -&gt; n -&gt; n **)
  let gcd a b =
    match a with
    | N0 -&gt; b
    | Npos p -&gt;
      (match b with
       | N0 -&gt; a
       | Npos q -&gt; Npos (Coq_Pos.gcd p q))
  (** val ggcd : n -&gt; n -&gt; (n, (n, n) prod) prod **)
  let ggcd a b =
    match a with
    | N0 -&gt; Pair (b, (Pair (N0, (Npos XH))))
    | Npos p -&gt;
      (match b with
       | N0 -&gt; Pair (a, (Pair ((Npos XH), N0)))
       | Npos q -&gt;
         let Pair (g, p0) = Coq_Pos.ggcd p q in
         let Pair (aa, bb) = p0 in
         Pair ((Npos g), (Pair ((Npos aa), (Npos bb)))))
  (** val sqrtrem : n -&gt; (n, n) prod **)
  let sqrtrem = function
  | N0 -&gt; Pair (N0, N0)
  | Npos p -&gt;
    let Pair (s, m) = Coq_Pos.sqrtrem p in
    (match m with
     | Coq_Pos.IsPos r -&gt; Pair ((Npos s), (Npos r))
     | _ -&gt; Pair ((Npos s), N0))
  (** val sqrt : n -&gt; n **)
  let sqrt = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.sqrt p)
  (** val coq_lor : n -&gt; n -&gt; n **)
  let coq_lor n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Npos (Coq_Pos.coq_lor p q))
  (** val coq_land : n -&gt; n -&gt; n **)
  let coq_land n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; N0
       | Npos q -&gt; Coq_Pos.coq_land p q)
  (** val ldiff : n -&gt; n -&gt; n **)
  let rec ldiff n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Coq_Pos.ldiff p q)
  (** val coq_lxor : n -&gt; n -&gt; n **)
  let coq_lxor n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Coq_Pos.coq_lxor p q)
  (** val shiftl_nat : n -&gt; nat -&gt; n **)
  let shiftl_nat a n0 =
    nat_iter n0 double a
  (** val shiftr_nat : n -&gt; nat -&gt; n **)
  let shiftr_nat a n0 =
    nat_iter n0 div2 a
  (** val shiftl : n -&gt; n -&gt; n **)
  let shiftl a n0 =
    match a with
    | N0 -&gt; N0
    | Npos a0 -&gt; Npos (Coq_Pos.shiftl a0 n0)
  (** val shiftr : n -&gt; n -&gt; n **)
  let shiftr a = function
  | N0 -&gt; a
  | Npos p -&gt; Coq_Pos.iter p div2 a
  (** val testbit_nat : n -&gt; nat -&gt; bool **)
  let testbit_nat = function
  | N0 -&gt; (fun x -&gt; False)
  | Npos p -&gt; Coq_Pos.testbit_nat p
  (** val testbit : n -&gt; n -&gt; bool **)
  let testbit a n0 =
    match a with
    | N0 -&gt; False
    | Npos p -&gt; Coq_Pos.testbit p n0
  (** val to_nat : n -&gt; nat **)
  let to_nat = function
  | N0 -&gt; O
  | Npos p -&gt; Coq_Pos.to_nat p
  (** val of_nat : nat -&gt; n **)
  let of_nat = function
  | O -&gt; N0
  | S n&#39; -&gt; Npos (Coq_Pos.of_succ_nat n&#39;)
  (** val iter : n -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let iter n0 f x =
    match n0 with
    | N0 -&gt; x
    | Npos p -&gt; Coq_Pos.iter p f x
  (** val eq_dec : n -&gt; n -&gt; sumbool **)
  let eq_dec n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; Left
       | Npos p -&gt; Right)
    | Npos x -&gt;
      (match m with
       | N0 -&gt; Right
       | Npos p0 -&gt; Coq_Pos.eq_dec x p0)
  (** val discr : n -&gt; positive sumor **)
  let discr = function
  | N0 -&gt; Inright
  | Npos p -&gt; Inleft p
  (** val binary_rect :
      &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let binary_rect f0 f2 fS2 n0 =
    let f2&#39; = fun p -&gt; f2 (Npos p) in
    let fS2&#39; = fun p -&gt; fS2 (Npos p) in
    (match n0 with
     | N0 -&gt; f0
     | Npos p -&gt;
       let rec f = function
       | XI p1 -&gt; fS2&#39; p1 (f p1)
       | XO p1 -&gt; f2&#39; p1 (f p1)
       | XH -&gt; fS2 N0 f0
       in f p)
  (** val binary_rec :
      &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let binary_rec =
    binary_rect
  (** val peano_rect : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let peano_rect f0 f n0 =
    let f&#39; = fun p -&gt; f (Npos p) in
    (match n0 with
     | N0 -&gt; f0
     | Npos p -&gt; Coq_Pos.peano_rect (f N0 f0) f&#39; p)
  (** val peano_rec : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let peano_rec =
    peano_rect
  (** val leb_spec0 : n -&gt; n -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : n -&gt; n -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_BootStrap = 
   struct 
   end
  (** val recursion : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let recursion x =
    peano_rect x
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
     end
    module Tac = 
     struct 
     end
   end
  module Private_NZPow = 
   struct 
   end
  module Private_NZSqrt = 
   struct 
   end
  (** val sqrt_up : n -&gt; n **)
  let sqrt_up a =
    match compare N0 a with
    | Lt -&gt; succ (sqrt (pred a))
    | _ -&gt; N0
  (** val log2_up : n -&gt; n **)
  let log2_up a =
    match compare (Npos XH) a with
    | Lt -&gt; succ (log2 (pred a))
    | _ -&gt; N0
  module Private_NZDiv = 
   struct 
   end
  (** val lcm : n -&gt; n -&gt; n **)
  let lcm a b =
    mul a (div b (gcd a b))
  (** val eqb_spec : n -&gt; n -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val b2n : bool -&gt; n **)
  let b2n = function
  | True -&gt; Npos XH
  | False -&gt; N0
  (** val setbit : n -&gt; n -&gt; n **)
  let setbit a n0 =
    coq_lor a (shiftl (Npos XH) n0)
  (** val clearbit : n -&gt; n -&gt; n **)
  let clearbit a n0 =
    ldiff a (shiftl (Npos XH) n0)
  (** val ones : n -&gt; n **)
  let ones n0 =
    pred (shiftl (Npos XH) n0)
  (** val lnot : n -&gt; n -&gt; n **)
  let lnot a n0 =
    coq_lxor a (ones n0)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : n -&gt; n -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : n -&gt; n -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong : n -&gt; n -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : n -&gt; n -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : n -&gt; n -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong : n -&gt; n -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : n -&gt; n -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : n -&gt; n -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module Z = 
 struct 
  type t = z
  (** val zero : z **)
  let zero =
    Z0
  (** val one : z **)
  let one =
    Zpos XH
  (** val two : z **)
  let two =
    Zpos (XO XH)
  (** val double : z -&gt; z **)
  let double = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos (XO p)
  | Zneg p -&gt; Zneg (XO p)
  (** val succ_double : z -&gt; z **)
  let succ_double = function
  | Z0 -&gt; Zpos XH
  | Zpos p -&gt; Zpos (XI p)
  | Zneg p -&gt; Zneg (Coq_Pos.pred_double p)
  (** val pred_double : z -&gt; z **)
  let pred_double = function
  | Z0 -&gt; Zneg XH
  | Zpos p -&gt; Zpos (Coq_Pos.pred_double p)
  | Zneg p -&gt; Zneg (XI p)
  (** val pos_sub : positive -&gt; positive -&gt; z **)
  let rec pos_sub x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double (pos_sub p q)
       | XO q -&gt; succ_double (pos_sub p q)
       | XH -&gt; Zpos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; pred_double (pos_sub p q)
       | XO q -&gt; double (pos_sub p q)
       | XH -&gt; Zpos (Coq_Pos.pred_double p))
    | XH -&gt;
      (match y with
       | XI q -&gt; Zneg (XO q)
       | XO q -&gt; Zneg (Coq_Pos.pred_double q)
       | XH -&gt; Z0)
  (** val add : z -&gt; z -&gt; z **)
  let add x y =
    match x with
    | Z0 -&gt; y
    | Zpos x&#39; -&gt;
      (match y with
       | Z0 -&gt; x
       | Zpos y&#39; -&gt; Zpos (Coq_Pos.add x&#39; y&#39;)
       | Zneg y&#39; -&gt; pos_sub x&#39; y&#39;)
    | Zneg x&#39; -&gt;
      (match y with
       | Z0 -&gt; x
       | Zpos y&#39; -&gt; pos_sub y&#39; x&#39;
       | Zneg y&#39; -&gt; Zneg (Coq_Pos.add x&#39; y&#39;))
  (** val opp : z -&gt; z **)
  let opp = function
  | Z0 -&gt; Z0
  | Zpos x0 -&gt; Zneg x0
  | Zneg x0 -&gt; Zpos x0
  (** val succ : z -&gt; z **)
  let succ x =
    add x (Zpos XH)
  (** val pred : z -&gt; z **)
  let pred x =
    add x (Zneg XH)
  (** val sub : z -&gt; z -&gt; z **)
  let sub m n0 =
    add m (opp n0)
  (** val mul : z -&gt; z -&gt; z **)
  let mul x y =
    match x with
    | Z0 -&gt; Z0
    | Zpos x&#39; -&gt;
      (match y with
       | Z0 -&gt; Z0
       | Zpos y&#39; -&gt; Zpos (Coq_Pos.mul x&#39; y&#39;)
       | Zneg y&#39; -&gt; Zneg (Coq_Pos.mul x&#39; y&#39;))
    | Zneg x&#39; -&gt;
      (match y with
       | Z0 -&gt; Z0
       | Zpos y&#39; -&gt; Zneg (Coq_Pos.mul x&#39; y&#39;)
       | Zneg y&#39; -&gt; Zpos (Coq_Pos.mul x&#39; y&#39;))
  (** val pow_pos : z -&gt; positive -&gt; z **)
  let pow_pos z0 n0 =
    Coq_Pos.iter n0 (mul z0) (Zpos XH)
  (** val pow : z -&gt; z -&gt; z **)
  let pow x = function
  | Z0 -&gt; Zpos XH
  | Zpos p -&gt; pow_pos x p
  | Zneg p -&gt; Z0
  (** val square : z -&gt; z **)
  let square = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos (Coq_Pos.square p)
  | Zneg p -&gt; Zpos (Coq_Pos.square p)
  (** val compare : z -&gt; z -&gt; comparison **)
  let compare x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; Eq
       | Zpos y&#39; -&gt; Lt
       | Zneg y&#39; -&gt; Gt)
    | Zpos x&#39; -&gt;
      (match y with
       | Zpos y&#39; -&gt; Coq_Pos.compare x&#39; y&#39;
       | _ -&gt; Gt)
    | Zneg x&#39; -&gt;
      (match y with
       | Zneg y&#39; -&gt; compOpp (Coq_Pos.compare x&#39; y&#39;)
       | _ -&gt; Lt)
  (** val sgn : z -&gt; z **)
  let sgn = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos XH
  | Zneg p -&gt; Zneg XH
  (** val leb : z -&gt; z -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : z -&gt; z -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val geb : z -&gt; z -&gt; bool **)
  let geb x y =
    match compare x y with
    | Lt -&gt; False
    | _ -&gt; True
  (** val gtb : z -&gt; z -&gt; bool **)
  let gtb x y =
    match compare x y with
    | Gt -&gt; True
    | _ -&gt; False
  (** val eqb : z -&gt; z -&gt; bool **)
  let rec eqb x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; True
       | _ -&gt; False)
    | Zpos p -&gt;
      (match y with
       | Zpos q -&gt; Coq_Pos.eqb p q
       | _ -&gt; False)
    | Zneg p -&gt;
      (match y with
       | Zneg q -&gt; Coq_Pos.eqb p q
       | _ -&gt; False)
  (** val max : z -&gt; z -&gt; z **)
  let max n0 m =
    match compare n0 m with
    | Lt -&gt; m
    | _ -&gt; n0
  (** val min : z -&gt; z -&gt; z **)
  let min n0 m =
    match compare n0 m with
    | Gt -&gt; m
    | _ -&gt; n0
  (** val abs : z -&gt; z **)
  let abs = function
  | Zneg p -&gt; Zpos p
  | x -&gt; x
  (** val abs_nat : z -&gt; nat **)
  let abs_nat = function
  | Z0 -&gt; O
  | Zpos p -&gt; Coq_Pos.to_nat p
  | Zneg p -&gt; Coq_Pos.to_nat p
  (** val abs_N : z -&gt; n **)
  let abs_N = function
  | Z0 -&gt; N0
  | Zpos p -&gt; Npos p
  | Zneg p -&gt; Npos p
  (** val to_nat : z -&gt; nat **)
  let to_nat = function
  | Zpos p -&gt; Coq_Pos.to_nat p
  | _ -&gt; O
  (** val to_N : z -&gt; n **)
  let to_N = function
  | Zpos p -&gt; Npos p
  | _ -&gt; N0
  (** val of_nat : nat -&gt; z **)
  let of_nat = function
  | O -&gt; Z0
  | S n1 -&gt; Zpos (Coq_Pos.of_succ_nat n1)
  (** val of_N : n -&gt; z **)
  let of_N = function
  | N0 -&gt; Z0
  | Npos p -&gt; Zpos p
  (** val to_pos : z -&gt; positive **)
  let to_pos = function
  | Zpos p -&gt; p
  | _ -&gt; XH
  (** val iter : z -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let iter n0 f x =
    match n0 with
    | Zpos p -&gt; Coq_Pos.iter p f x
    | _ -&gt; x
  (** val pos_div_eucl : positive -&gt; z -&gt; (z, z) prod **)
  let rec pos_div_eucl a b =
    match a with
    | XI a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = add (mul (Zpos (XO XH)) r) (Zpos XH) in
      (match ltb r&#39; b with
       | True -&gt; Pair ((mul (Zpos (XO XH)) q), r&#39;)
       | False -&gt; Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r&#39; b)))
    | XO a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = mul (Zpos (XO XH)) r in
      (match ltb r&#39; b with
       | True -&gt; Pair ((mul (Zpos (XO XH)) q), r&#39;)
       | False -&gt; Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r&#39; b)))
    | XH -&gt;
      (match leb (Zpos (XO XH)) b with
       | True -&gt; Pair (Z0, (Zpos XH))
       | False -&gt; Pair ((Zpos XH), Z0))
  (** val div_eucl : z -&gt; z -&gt; (z, z) prod **)
  let div_eucl a b =
    match a with
    | Z0 -&gt; Pair (Z0, Z0)
    | Zpos a&#39; -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, Z0)
       | Zpos p -&gt; pos_div_eucl a&#39; b
       | Zneg b&#39; -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; (Zpos b&#39;) in
         (match r with
          | Z0 -&gt; Pair ((opp q), Z0)
          | _ -&gt; Pair ((opp (add q (Zpos XH))), (add b r))))
    | Zneg a&#39; -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, Z0)
       | Zpos p -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; b in
         (match r with
          | Z0 -&gt; Pair ((opp q), Z0)
          | _ -&gt; Pair ((opp (add q (Zpos XH))), (sub b r)))
       | Zneg b&#39; -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; (Zpos b&#39;) in Pair (q, (opp r)))
  (** val div : z -&gt; z -&gt; z **)
  let div a b =
    let Pair (q, x) = div_eucl a b in q
  (** val modulo : z -&gt; z -&gt; z **)
  let modulo a b =
    let Pair (x, r) = div_eucl a b in r
  (** val quotrem : z -&gt; z -&gt; (z, z) prod **)
  let quotrem a b =
    match a with
    | Z0 -&gt; Pair (Z0, Z0)
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, a)
       | Zpos b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (of_N r))
       | Zneg b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (of_N r)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, a)
       | Zpos b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (opp (of_N r)))
       | Zneg b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (opp (of_N r))))
  (** val quot : z -&gt; z -&gt; z **)
  let quot a b =
    fst (quotrem a b)
  (** val rem : z -&gt; z -&gt; z **)
  let rem a b =
    snd (quotrem a b)
  (** val even : z -&gt; bool **)
  let even = function
  | Z0 -&gt; True
  | Zpos p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  | Zneg p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  (** val odd : z -&gt; bool **)
  let odd = function
  | Z0 -&gt; False
  | Zpos p -&gt;
    (match p with
     | XO p0 -&gt; False
     | _ -&gt; True)
  | Zneg p -&gt;
    (match p with
     | XO p0 -&gt; False
     | _ -&gt; True)
  (** val div2 : z -&gt; z **)
  let div2 = function
  | Z0 -&gt; Z0
  | Zpos p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zpos (Coq_Pos.div2 p))
  | Zneg p -&gt; Zneg (Coq_Pos.div2_up p)
  (** val quot2 : z -&gt; z **)
  let quot2 = function
  | Z0 -&gt; Z0
  | Zpos p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zpos (Coq_Pos.div2 p))
  | Zneg p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zneg (Coq_Pos.div2 p))
  (** val log2 : z -&gt; z **)
  let log2 = function
  | Zpos p0 -&gt;
    (match p0 with
     | XI p -&gt; Zpos (Coq_Pos.size p)
     | XO p -&gt; Zpos (Coq_Pos.size p)
     | XH -&gt; Z0)
  | _ -&gt; Z0
  (** val sqrtrem : z -&gt; (z, z) prod **)
  let sqrtrem = function
  | Zpos p -&gt;
    let Pair (s, m) = Coq_Pos.sqrtrem p in
    (match m with
     | Coq_Pos.IsPos r -&gt; Pair ((Zpos s), (Zpos r))
     | _ -&gt; Pair ((Zpos s), Z0))
  | _ -&gt; Pair (Z0, Z0)
  (** val sqrt : z -&gt; z **)
  let sqrt = function
  | Zpos p -&gt; Zpos (Coq_Pos.sqrt p)
  | _ -&gt; Z0
  (** val gcd : z -&gt; z -&gt; z **)
  let gcd a b =
    match a with
    | Z0 -&gt; abs b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; abs a
       | Zpos b0 -&gt; Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -&gt; Zpos (Coq_Pos.gcd a0 b0))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; abs a
       | Zpos b0 -&gt; Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -&gt; Zpos (Coq_Pos.gcd a0 b0))
  (** val ggcd : z -&gt; z -&gt; (z, (z, z) prod) prod **)
  let ggcd a b =
    match a with
    | Z0 -&gt; Pair ((abs b), (Pair (Z0, (sgn b))))
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zpos bb))))
       | Zneg b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zneg bb)))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zpos bb))))
       | Zneg b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zneg bb)))))
  (** val testbit : z -&gt; z -&gt; bool **)
  let testbit a = function
  | Z0 -&gt; odd a
  | Zpos p -&gt;
    (match a with
     | Z0 -&gt; False
     | Zpos a0 -&gt; Coq_Pos.testbit a0 (Npos p)
     | Zneg a0 -&gt; negb (N.testbit (Coq_Pos.pred_N a0) (Npos p)))
  | Zneg p -&gt; False
  (** val shiftl : z -&gt; z -&gt; z **)
  let shiftl a = function
  | Z0 -&gt; a
  | Zpos p -&gt; Coq_Pos.iter p (mul (Zpos (XO XH))) a
  | Zneg p -&gt; Coq_Pos.iter p div2 a
  (** val shiftr : z -&gt; z -&gt; z **)
  let shiftr a n0 =
    shiftl a (opp n0)
  (** val coq_lor : z -&gt; z -&gt; z **)
  let coq_lor a b =
    match a with
    | Z0 -&gt; b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; Zpos (Coq_Pos.coq_lor a0 b0)
       | Zneg b0 -&gt; Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N b0) (Npos a0))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt;
         Zneg
           (N.succ_pos (N.coq_land (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  (** val coq_land : z -&gt; z -&gt; z **)
  let coq_land a b =
    match a with
    | Z0 -&gt; Z0
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Z0
       | Zpos b0 -&gt; of_N (Coq_Pos.coq_land a0 b0)
       | Zneg b0 -&gt; of_N (N.ldiff (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Z0
       | Zpos b0 -&gt; of_N (N.ldiff (Npos b0) (Coq_Pos.pred_N a0))
       | Zneg b0 -&gt;
         Zneg
           (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  (** val ldiff : z -&gt; z -&gt; z **)
  let ldiff a b =
    match a with
    | Z0 -&gt; Z0
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; of_N (Coq_Pos.ldiff a0 b0)
       | Zneg b0 -&gt; of_N (N.coq_land (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt;
         Zneg (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt; of_N (N.ldiff (Coq_Pos.pred_N b0) (Coq_Pos.pred_N a0)))
  (** val coq_lxor : z -&gt; z -&gt; z **)
  let coq_lxor a b =
    match a with
    | Z0 -&gt; b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; of_N (Coq_Pos.coq_lxor a0 b0)
       | Zneg b0 -&gt;
         Zneg (N.succ_pos (N.coq_lxor (Npos a0) (Coq_Pos.pred_N b0))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt;
         Zneg (N.succ_pos (N.coq_lxor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt; of_N (N.coq_lxor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0)))
  (** val eq_dec : z -&gt; z -&gt; sumbool **)
  let eq_dec x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; Left
       | _ -&gt; Right)
    | Zpos x0 -&gt;
      (match y with
       | Zpos p0 -&gt; Coq_Pos.eq_dec x0 p0
       | _ -&gt; Right)
    | Zneg x0 -&gt;
      (match y with
       | Zneg p0 -&gt; Coq_Pos.eq_dec x0 p0
       | _ -&gt; Right)
  module Private_BootStrap = 
   struct 
   end
  (** val leb_spec0 : z -&gt; z -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : z -&gt; z -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
     end
    module Tac = 
     struct 
     end
   end
  (** val sqrt_up : z -&gt; z **)
  let sqrt_up a =
    match compare Z0 a with
    | Lt -&gt; succ (sqrt (pred a))
    | _ -&gt; Z0
  (** val log2_up : z -&gt; z **)
  let log2_up a =
    match compare (Zpos XH) a with
    | Lt -&gt; succ (log2 (pred a))
    | _ -&gt; Z0
  module Private_NZDiv = 
   struct 
   end
  module Private_Div = 
   struct 
    module Quot2Div = 
     struct 
      (** val div : z -&gt; z -&gt; z **)
      let div =
        quot
      (** val modulo : z -&gt; z -&gt; z **)
      let modulo =
        rem
     end
    module NZQuot = 
     struct 
     end
   end
  (** val lcm : z -&gt; z -&gt; z **)
  let lcm a b =
    abs (mul a (div b (gcd a b)))
  (** val eqb_spec : z -&gt; z -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val b2z : bool -&gt; z **)
  let b2z = function
  | True -&gt; Zpos XH
  | False -&gt; Z0
  (** val setbit : z -&gt; z -&gt; z **)
  let setbit a n0 =
    coq_lor a (shiftl (Zpos XH) n0)
  (** val clearbit : z -&gt; z -&gt; z **)
  let clearbit a n0 =
    ldiff a (shiftl (Zpos XH) n0)
  (** val lnot : z -&gt; z **)
  let lnot a =
    pred (opp a)
  (** val ones : z -&gt; z **)
  let ones n0 =
    pred (shiftl (Zpos XH) n0)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : z -&gt; z -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : z -&gt; z -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong : z -&gt; z -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : z -&gt; z -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : z -&gt; z -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong : z -&gt; z -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : z -&gt; z -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : z -&gt; z -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module LOCAL = 
 struct 
  type &#39;x coq_Compare =
  | LT
  | EQ
  | GT
  (** val coq_Compare_rect :
      &#39;a1 -&gt; &#39;a1 -&gt; (__ -&gt; &#39;a2) -&gt; (__ -&gt; &#39;a2) -&gt; (__ -&gt; &#39;a2) -&gt; &#39;a1
      coq_Compare -&gt; &#39;a2 **)
  let coq_Compare_rect x y f f0 f1 = function
  | LT -&gt; f __
  | EQ -&gt; f0 __
  | GT -&gt; f1 __
  (** val coq_Compare_rec :
      &#39;a1 -&gt; &#39;a1 -&gt; (__ -&gt; &#39;a2) -&gt; (__ -&gt; &#39;a2) -&gt; (__ -&gt; &#39;a2) -&gt; &#39;a1
      coq_Compare -&gt; &#39;a2 **)
  let coq_Compare_rec x y f f0 f1 = function
  | LT -&gt; f __
  | EQ -&gt; f0 __
  | GT -&gt; f1 __
  module type OrderedType = 
   sig 
    type t 
    val compare : t -&gt; t -&gt; t coq_Compare
   end
  module Z_as_OT = 
   struct 
    type t = z
    (** val compare : z -&gt; z -&gt; z coq_Compare **)
    let compare x y =
      match Z.compare x y with
      | Eq -&gt; EQ
      | Lt -&gt; LT
      | Gt -&gt; GT
   end
 end
M.add
     : M.elt -&gt; M.t -&gt; M.t
     = true
     : bool
     = 0 :: 2 :: nil
     : list M.elt
M.elements_3 ens3
     : Sorted (fun x y : Z =&gt; x &lt; y) (M.elements ens3)
     = {|
       M.MSet.this := Node 2 (Node 1 Leaf 0 Leaf) 2 (Node 1 Leaf 3 Leaf);
       M.MSet.is_ok := @add_ok (Node 2 (Node 1 Leaf 0 Leaf) 2 Leaf) 3
                         (@add_ok (Node 1 Leaf 2 Leaf) 0
                            (@add_ok Leaf 2 empty_ok)) |}
     : M.t
     = {|
       M.MSet.this := Node 2 Leaf 0 (Node 1 Leaf 2 Leaf);
       M.MSet.is_ok := @inter_ok
                         (Node 2 (Node 1 Leaf 0 Leaf) 2 (Node 1 Leaf 3 Leaf))
                         (Node 3 (Node 2 (Node 1 Leaf 0 Leaf) 2 Leaf) 4 Leaf)
                         (@add_ok (Node 2 (Node 1 Leaf 0 Leaf) 2 Leaf) 3
                            (@add_ok (Node 1 Leaf 2 Leaf) 0
                               (@add_ok Leaf 2 empty_ok)))
                         (@add_ok (Node 2 (Node 1 Leaf 2 Leaf) 4 Leaf) 0
                            (@add_ok (Node 1 Leaf 4 Leaf) 2
                               (@add_ok Leaf 4 empty_ok))) |}
     : M.t
     = R.Node 2 R.Leaf 0 (R.Node 1 R.Leaf 2 R.Leaf)
     : R.tree
     = 0 :: 2 :: nil
     : list Z
elements_spec1 raw3
     : forall x : Z, InA Logic.eq x (elements raw3) &lt;-&gt; InT x raw3
elements_spec2 raw3 Ok_instance_0
     : Sorted (fun x y : Z =&gt; x &lt; y) (elements raw3)
     = R.Node 3 (R.Node 1 R.Leaf 0 R.Leaf) 2
         (R.Node 2 (R.Node 1 R.Leaf 3 R.Leaf) 4 R.Leaf)
     : R.tree
type __ = Obj.t
let __ = let rec f _ = Obj.repr f in Obj.repr f
type bool =
| True
| False
(** val negb : bool -&gt; bool **)
let negb = function
| True -&gt; False
| False -&gt; True
type nat =
| O
| S of nat
type &#39;a option =
| Some of &#39;a
| None
type (&#39;a, &#39;b) prod =
| Pair of &#39;a * &#39;b
(** val fst : (&#39;a1, &#39;a2) prod -&gt; &#39;a1 **)
let fst = function
| Pair (x, y) -&gt; x
(** val snd : (&#39;a1, &#39;a2) prod -&gt; &#39;a2 **)
let snd = function
| Pair (x, y) -&gt; y
type &#39;a list =
| Nil
| Cons of &#39;a * &#39;a list
(** val app : &#39;a1 list -&gt; &#39;a1 list -&gt; &#39;a1 list **)
let rec app l m =
  match l with
  | Nil -&gt; m
  | Cons (a, l1) -&gt; Cons (a, (app l1 m))
type comparison =
| Eq
| Lt
| Gt
(** val compOpp : comparison -&gt; comparison **)
let compOpp = function
| Eq -&gt; Eq
| Lt -&gt; Gt
| Gt -&gt; Lt
type compareSpecT =
| CompEqT
| CompLtT
| CompGtT
(** val compareSpec2Type : comparison -&gt; compareSpecT **)
let compareSpec2Type = function
| Eq -&gt; CompEqT
| Lt -&gt; CompLtT
| Gt -&gt; CompGtT
type &#39;a compSpecT = compareSpecT
(** val compSpec2Type : &#39;a1 -&gt; &#39;a1 -&gt; comparison -&gt; &#39;a1 compSpecT **)
let compSpec2Type x y c =
  compareSpec2Type c
type &#39;a sig0 =
  &#39;a
  (* singleton inductive, whose constructor was exist *)
type sumbool =
| Left
| Right
type &#39;a sumor =
| Inleft of &#39;a
| Inright
(** val plus : nat -&gt; nat -&gt; nat **)
let rec plus n0 m =
  match n0 with
  | O -&gt; m
  | S p -&gt; S (plus p m)
(** val max : nat -&gt; nat -&gt; nat **)
let rec max n0 m =
  match n0 with
  | O -&gt; m
  | S n&#39; -&gt;
    (match m with
     | O -&gt; n0
     | S m&#39; -&gt; S (max n&#39; m&#39;))
(** val min : nat -&gt; nat -&gt; nat **)
let rec min n0 m =
  match n0 with
  | O -&gt; O
  | S n&#39; -&gt;
    (match m with
     | O -&gt; O
     | S m&#39; -&gt; S (min n&#39; m&#39;))
(** val nat_iter : nat -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
let rec nat_iter n0 f x =
  match n0 with
  | O -&gt; x
  | S n&#39; -&gt; f (nat_iter n&#39; f x)
type reflect =
| ReflectT
| ReflectF
(** val iff_reflect : bool -&gt; reflect **)
let iff_reflect = function
| True -&gt; ReflectT
| False -&gt; ReflectF
module type OrderedType = 
 sig 
  type t 
  val compare : t -&gt; t -&gt; comparison
  val eq_dec : t -&gt; t -&gt; sumbool
 end
module type OrderedType&#39; = 
 sig 
  type t 
  val compare : t -&gt; t -&gt; comparison
  val eq_dec : t -&gt; t -&gt; sumbool
 end
module OT_to_Full = 
 functor (O:OrderedType&#39;) -&gt;
 struct 
  type t = O.t
  (** val compare : t -&gt; t -&gt; comparison **)
  let compare =
    O.compare
  (** val eq_dec : t -&gt; t -&gt; sumbool **)
  let eq_dec =
    O.eq_dec
 end
module OT_to_OrderTac = 
 functor (OT:OrderedType) -&gt;
 struct 
  module OTF = OT_to_Full(OT)
  module TO = 
   struct 
    type t = OTF.t
    (** val compare : t -&gt; t -&gt; comparison **)
    let compare =
      OTF.compare
    (** val eq_dec : t -&gt; t -&gt; sumbool **)
    let eq_dec =
      OTF.eq_dec
   end
 end
type &#39;x compare0 =
| LT
| EQ
| GT
module type Coq_OrderedType = 
 sig 
  type t 
  val compare : t -&gt; t -&gt; t compare0
  val eq_dec : t -&gt; t -&gt; sumbool
 end
type positive =
| XI of positive
| XO of positive
| XH
type n =
| N0
| Npos of positive
type z =
| Z0
| Zpos of positive
| Zneg of positive
module OrderedTypeFacts = 
 functor (O:OrderedType&#39;) -&gt;
 struct 
  module OrderTac = OT_to_OrderTac(O)
  (** val eq_dec : O.t -&gt; O.t -&gt; sumbool **)
  let eq_dec =
    O.eq_dec
  (** val lt_dec : O.t -&gt; O.t -&gt; sumbool **)
  let lt_dec x y =
    let c = compSpec2Type x y (O.compare x y) in
    (match c with
     | CompLtT -&gt; Left
     | _ -&gt; Right)
  (** val eqb : O.t -&gt; O.t -&gt; bool **)
  let eqb x y =
    match eq_dec x y with
    | Left -&gt; True
    | Right -&gt; False
 end
module Pos = 
 struct 
  type t = positive
  (** val succ : positive -&gt; positive **)
  let rec succ = function
  | XI p -&gt; XO (succ p)
  | XO p -&gt; XI p
  | XH -&gt; XO XH
  (** val add : positive -&gt; positive -&gt; positive **)
  let rec add x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XI (add p q)
       | XO q -&gt; XO (add p q)
       | XH -&gt; XI p)
    | XH -&gt;
      (match y with
       | XI q -&gt; XO (succ q)
       | XO q -&gt; XI q
       | XH -&gt; XO XH)
  (** val add_carry : positive -&gt; positive -&gt; positive **)
  and add_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XI (add_carry p q)
       | XO q -&gt; XO (add_carry p q)
       | XH -&gt; XI (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XH -&gt;
      (match y with
       | XI q -&gt; XI (succ q)
       | XO q -&gt; XO (succ q)
       | XH -&gt; XI XH)
  (** val pred_double : positive -&gt; positive **)
  let rec pred_double = function
  | XI p -&gt; XI (XO p)
  | XO p -&gt; XI (pred_double p)
  | XH -&gt; XH
  (** val pred : positive -&gt; positive **)
  let pred = function
  | XI p -&gt; XO p
  | XO p -&gt; pred_double p
  | XH -&gt; XH
  (** val pred_N : positive -&gt; n **)
  let pred_N = function
  | XI p -&gt; Npos (XO p)
  | XO p -&gt; Npos (pred_double p)
  | XH -&gt; N0
  type mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  (** val mask_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rect f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val mask_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rec f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val succ_double_mask : mask -&gt; mask **)
  let succ_double_mask = function
  | IsNul -&gt; IsPos XH
  | IsPos p -&gt; IsPos (XI p)
  | IsNeg -&gt; IsNeg
  (** val double_mask : mask -&gt; mask **)
  let double_mask = function
  | IsPos p -&gt; IsPos (XO p)
  | x0 -&gt; x0
  (** val double_pred_mask : positive -&gt; mask **)
  let double_pred_mask = function
  | XI p -&gt; IsPos (XO (XO p))
  | XO p -&gt; IsPos (XO (pred_double p))
  | XH -&gt; IsNul
  (** val pred_mask : mask -&gt; mask **)
  let pred_mask = function
  | IsPos q -&gt;
    (match q with
     | XH -&gt; IsNul
     | _ -&gt; IsPos (pred q))
  | _ -&gt; IsNeg
  (** val sub_mask : positive -&gt; positive -&gt; mask **)
  let rec sub_mask x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask p q)
       | XO q -&gt; succ_double_mask (sub_mask p q)
       | XH -&gt; IsPos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XH -&gt;
      (match y with
       | XH -&gt; IsNul
       | _ -&gt; IsNeg)
  (** val sub_mask_carry : positive -&gt; positive -&gt; mask **)
  and sub_mask_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask_carry p q)
       | XO q -&gt; succ_double_mask (sub_mask_carry p q)
       | XH -&gt; double_pred_mask p)
    | XH -&gt; IsNeg
  (** val sub : positive -&gt; positive -&gt; positive **)
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -&gt; z0
    | _ -&gt; XH
  (** val mul : positive -&gt; positive -&gt; positive **)
  let rec mul x y =
    match x with
    | XI p -&gt; add y (XO (mul p y))
    | XO p -&gt; XO (mul p y)
    | XH -&gt; y
  (** val iter : positive -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter n0 f x =
    match n0 with
    | XI n&#39; -&gt; f (iter n&#39; f (iter n&#39; f x))
    | XO n&#39; -&gt; iter n&#39; f (iter n&#39; f x)
    | XH -&gt; f x
  (** val pow : positive -&gt; positive -&gt; positive **)
  let pow x y =
    iter y (mul x) XH
  (** val square : positive -&gt; positive **)
  let rec square = function
  | XI p0 -&gt; XI (XO (add (square p0) p0))
  | XO p0 -&gt; XO (XO (square p0))
  | XH -&gt; XH
  (** val div2 : positive -&gt; positive **)
  let div2 = function
  | XI p0 -&gt; p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val div2_up : positive -&gt; positive **)
  let div2_up = function
  | XI p0 -&gt; succ p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val size_nat : positive -&gt; nat **)
  let rec size_nat = function
  | XI p0 -&gt; S (size_nat p0)
  | XO p0 -&gt; S (size_nat p0)
  | XH -&gt; S O
  (** val size : positive -&gt; positive **)
  let rec size = function
  | XI p0 -&gt; succ (size p0)
  | XO p0 -&gt; succ (size p0)
  | XH -&gt; XH
  (** val compare_cont : positive -&gt; positive -&gt; comparison -&gt; comparison **)
  let rec compare_cont x y r =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q r
       | XO q -&gt; compare_cont p q Gt
       | XH -&gt; Gt)
    | XO p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q Lt
       | XO q -&gt; compare_cont p q r
       | XH -&gt; Gt)
    | XH -&gt;
      (match y with
       | XH -&gt; r
       | _ -&gt; Lt)
  (** val compare : positive -&gt; positive -&gt; comparison **)
  let compare x y =
    compare_cont x y Eq
  (** val min : positive -&gt; positive -&gt; positive **)
  let min p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p&#39;
    | _ -&gt; p
  (** val max : positive -&gt; positive -&gt; positive **)
  let max p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p
    | _ -&gt; p&#39;
  (** val eqb : positive -&gt; positive -&gt; bool **)
  let rec eqb p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XO p0 -&gt;
      (match q with
       | XO q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XH -&gt;
      (match q with
       | XH -&gt; True
       | _ -&gt; False)
  (** val leb : positive -&gt; positive -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : positive -&gt; positive -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val sqrtrem_step :
      (positive -&gt; positive) -&gt; (positive -&gt; positive) -&gt; (positive, mask)
      prod -&gt; (positive, mask) prod **)
  let sqrtrem_step f g = function
  | Pair (s, y) -&gt;
    (match y with
     | IsPos r -&gt;
       let s&#39; = XI (XO s) in
       let r&#39; = g (f r) in
       (match leb s&#39; r&#39; with
        | True -&gt; Pair ((XI s), (sub_mask r&#39; s&#39;))
        | False -&gt; Pair ((XO s), (IsPos r&#39;)))
     | _ -&gt; Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  (** val sqrtrem : positive -&gt; (positive, mask) prod **)
  let rec sqrtrem = function
  | XI p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XI x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XI x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos (XO XH))))
  | XO p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XO x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XO x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos XH)))
  | XH -&gt; Pair (XH, IsNul)
  (** val sqrt : positive -&gt; positive **)
  let sqrt p =
    fst (sqrtrem p)
  (** val gcdn : nat -&gt; positive -&gt; positive -&gt; positive **)
  let rec gcdn n0 a b =
    match n0 with
    | O -&gt; XH
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; a
             | Lt -&gt; gcdn n1 (sub b&#39; a&#39;) a
             | Gt -&gt; gcdn n1 (sub a&#39; b&#39;) b)
          | XO b0 -&gt; gcdn n1 a b0
          | XH -&gt; XH)
       | XO a0 -&gt;
         (match b with
          | XI p -&gt; gcdn n1 a0 b
          | XO b0 -&gt; XO (gcdn n1 a0 b0)
          | XH -&gt; XH)
       | XH -&gt; XH)
  (** val gcd : positive -&gt; positive -&gt; positive **)
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  (** val ggcdn :
      nat -&gt; positive -&gt; positive -&gt; (positive, (positive, positive) prod)
      prod **)
  let rec ggcdn n0 a b =
    match n0 with
    | O -&gt; Pair (XH, (Pair (a, b)))
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; Pair (a, (Pair (XH, XH)))
             | Lt -&gt;
               let Pair (g, p) = ggcdn n1 (sub b&#39; a&#39;) a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt -&gt;
               let Pair (g, p) = ggcdn n1 (sub a&#39; b&#39;) b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 -&gt;
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XO a0 -&gt;
         (match b with
          | XI p -&gt;
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -&gt; let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XH -&gt; Pair (XH, (Pair (XH, b))))
  (** val ggcd :
      positive -&gt; positive -&gt; (positive, (positive, positive) prod) prod **)
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  (** val coq_Nsucc_double : n -&gt; n **)
  let coq_Nsucc_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val coq_Ndouble : n -&gt; n **)
  let coq_Ndouble = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val coq_lor : positive -&gt; positive -&gt; positive **)
  let rec coq_lor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XI (coq_lor p0 q0)
       | XH -&gt; p)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XO (coq_lor p0 q0)
       | XH -&gt; XI p0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; XI q0
       | _ -&gt; q)
  (** val coq_land : positive -&gt; positive -&gt; n **)
  let rec coq_land p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; Npos XH)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; N0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; N0
       | _ -&gt; Npos XH)
  (** val ldiff : positive -&gt; positive -&gt; n **)
  let rec ldiff p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (ldiff p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XH -&gt; Npos p)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; Npos XH
       | _ -&gt; N0)
  (** val coq_lxor : positive -&gt; positive -&gt; n **)
  let rec coq_lxor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XH -&gt; Npos (XI p0))
    | XH -&gt;
      (match q with
       | XI q0 -&gt; Npos (XO q0)
       | XO q0 -&gt; Npos (XI q0)
       | XH -&gt; N0)
  (** val shiftl_nat : positive -&gt; nat -&gt; positive **)
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -&gt; XO x) p
  (** val shiftr_nat : positive -&gt; nat -&gt; positive **)
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  (** val shiftl : positive -&gt; n -&gt; positive **)
  let shiftl p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 (fun x -&gt; XO x) p
  (** val shiftr : positive -&gt; n -&gt; positive **)
  let shiftr p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 div2 p
  (** val testbit_nat : positive -&gt; nat -&gt; bool **)
  let rec testbit_nat p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | O -&gt; True
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XO p0 -&gt;
      (match n0 with
       | O -&gt; False
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XH -&gt;
      (match n0 with
       | O -&gt; True
       | S n1 -&gt; False)
  (** val testbit : positive -&gt; n -&gt; bool **)
  let rec testbit p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XO p0 -&gt;
      (match n0 with
       | N0 -&gt; False
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XH -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos p0 -&gt; False)
  (** val iter_op : (&#39;a1 -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter_op op p a =
    match p with
    | XI p0 -&gt; op a (iter_op op p0 (op a a))
    | XO p0 -&gt; iter_op op p0 (op a a)
    | XH -&gt; a
  (** val to_nat : positive -&gt; nat **)
  let to_nat x =
    iter_op plus x (S O)
  (** val of_nat : nat -&gt; positive **)
  let rec of_nat = function
  | O -&gt; XH
  | S x -&gt;
    (match x with
     | O -&gt; XH
     | S n1 -&gt; succ (of_nat x))
  (** val of_succ_nat : nat -&gt; positive **)
  let rec of_succ_nat = function
  | O -&gt; XH
  | S x -&gt; succ (of_succ_nat x)
 end
module Coq_Pos = 
 struct 
  type t = positive
  (** val succ : positive -&gt; positive **)
  let rec succ = function
  | XI p -&gt; XO (succ p)
  | XO p -&gt; XI p
  | XH -&gt; XO XH
  (** val add : positive -&gt; positive -&gt; positive **)
  let rec add x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XI (add p q)
       | XO q -&gt; XO (add p q)
       | XH -&gt; XI p)
    | XH -&gt;
      (match y with
       | XI q -&gt; XO (succ q)
       | XO q -&gt; XI q
       | XH -&gt; XO XH)
  (** val add_carry : positive -&gt; positive -&gt; positive **)
  and add_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XI (add_carry p q)
       | XO q -&gt; XO (add_carry p q)
       | XH -&gt; XI (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XH -&gt;
      (match y with
       | XI q -&gt; XI (succ q)
       | XO q -&gt; XO (succ q)
       | XH -&gt; XI XH)
  (** val pred_double : positive -&gt; positive **)
  let rec pred_double = function
  | XI p -&gt; XI (XO p)
  | XO p -&gt; XI (pred_double p)
  | XH -&gt; XH
  (** val pred : positive -&gt; positive **)
  let pred = function
  | XI p -&gt; XO p
  | XO p -&gt; pred_double p
  | XH -&gt; XH
  (** val pred_N : positive -&gt; n **)
  let pred_N = function
  | XI p -&gt; Npos (XO p)
  | XO p -&gt; Npos (pred_double p)
  | XH -&gt; N0
  type mask = Pos.mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  (** val mask_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rect f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val mask_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rec f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val succ_double_mask : mask -&gt; mask **)
  let succ_double_mask = function
  | IsNul -&gt; IsPos XH
  | IsPos p -&gt; IsPos (XI p)
  | IsNeg -&gt; IsNeg
  (** val double_mask : mask -&gt; mask **)
  let double_mask = function
  | IsPos p -&gt; IsPos (XO p)
  | x0 -&gt; x0
  (** val double_pred_mask : positive -&gt; mask **)
  let double_pred_mask = function
  | XI p -&gt; IsPos (XO (XO p))
  | XO p -&gt; IsPos (XO (pred_double p))
  | XH -&gt; IsNul
  (** val pred_mask : mask -&gt; mask **)
  let pred_mask = function
  | IsPos q -&gt;
    (match q with
     | XH -&gt; IsNul
     | _ -&gt; IsPos (pred q))
  | _ -&gt; IsNeg
  (** val sub_mask : positive -&gt; positive -&gt; mask **)
  let rec sub_mask x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask p q)
       | XO q -&gt; succ_double_mask (sub_mask p q)
       | XH -&gt; IsPos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XH -&gt;
      (match y with
       | XH -&gt; IsNul
       | _ -&gt; IsNeg)
  (** val sub_mask_carry : positive -&gt; positive -&gt; mask **)
  and sub_mask_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask_carry p q)
       | XO q -&gt; succ_double_mask (sub_mask_carry p q)
       | XH -&gt; double_pred_mask p)
    | XH -&gt; IsNeg
  (** val sub : positive -&gt; positive -&gt; positive **)
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -&gt; z0
    | _ -&gt; XH
  (** val mul : positive -&gt; positive -&gt; positive **)
  let rec mul x y =
    match x with
    | XI p -&gt; add y (XO (mul p y))
    | XO p -&gt; XO (mul p y)
    | XH -&gt; y
  (** val iter : positive -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter n0 f x =
    match n0 with
    | XI n&#39; -&gt; f (iter n&#39; f (iter n&#39; f x))
    | XO n&#39; -&gt; iter n&#39; f (iter n&#39; f x)
    | XH -&gt; f x
  (** val pow : positive -&gt; positive -&gt; positive **)
  let pow x y =
    iter y (mul x) XH
  (** val square : positive -&gt; positive **)
  let rec square = function
  | XI p0 -&gt; XI (XO (add (square p0) p0))
  | XO p0 -&gt; XO (XO (square p0))
  | XH -&gt; XH
  (** val div2 : positive -&gt; positive **)
  let div2 = function
  | XI p0 -&gt; p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val div2_up : positive -&gt; positive **)
  let div2_up = function
  | XI p0 -&gt; succ p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val size_nat : positive -&gt; nat **)
  let rec size_nat = function
  | XI p0 -&gt; S (size_nat p0)
  | XO p0 -&gt; S (size_nat p0)
  | XH -&gt; S O
  (** val size : positive -&gt; positive **)
  let rec size = function
  | XI p0 -&gt; succ (size p0)
  | XO p0 -&gt; succ (size p0)
  | XH -&gt; XH
  (** val compare_cont : positive -&gt; positive -&gt; comparison -&gt; comparison **)
  let rec compare_cont x y r =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q r
       | XO q -&gt; compare_cont p q Gt
       | XH -&gt; Gt)
    | XO p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q Lt
       | XO q -&gt; compare_cont p q r
       | XH -&gt; Gt)
    | XH -&gt;
      (match y with
       | XH -&gt; r
       | _ -&gt; Lt)
  (** val compare : positive -&gt; positive -&gt; comparison **)
  let compare x y =
    compare_cont x y Eq
  (** val min : positive -&gt; positive -&gt; positive **)
  let min p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p&#39;
    | _ -&gt; p
  (** val max : positive -&gt; positive -&gt; positive **)
  let max p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p
    | _ -&gt; p&#39;
  (** val eqb : positive -&gt; positive -&gt; bool **)
  let rec eqb p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XO p0 -&gt;
      (match q with
       | XO q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XH -&gt;
      (match q with
       | XH -&gt; True
       | _ -&gt; False)
  (** val leb : positive -&gt; positive -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : positive -&gt; positive -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val sqrtrem_step :
      (positive -&gt; positive) -&gt; (positive -&gt; positive) -&gt; (positive, mask)
      prod -&gt; (positive, mask) prod **)
  let sqrtrem_step f g = function
  | Pair (s, y) -&gt;
    (match y with
     | IsPos r -&gt;
       let s&#39; = XI (XO s) in
       let r&#39; = g (f r) in
       (match leb s&#39; r&#39; with
        | True -&gt; Pair ((XI s), (sub_mask r&#39; s&#39;))
        | False -&gt; Pair ((XO s), (IsPos r&#39;)))
     | _ -&gt; Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  (** val sqrtrem : positive -&gt; (positive, mask) prod **)
  let rec sqrtrem = function
  | XI p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XI x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XI x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos (XO XH))))
  | XO p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XO x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XO x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos XH)))
  | XH -&gt; Pair (XH, IsNul)
  (** val sqrt : positive -&gt; positive **)
  let sqrt p =
    fst (sqrtrem p)
  (** val gcdn : nat -&gt; positive -&gt; positive -&gt; positive **)
  let rec gcdn n0 a b =
    match n0 with
    | O -&gt; XH
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; a
             | Lt -&gt; gcdn n1 (sub b&#39; a&#39;) a
             | Gt -&gt; gcdn n1 (sub a&#39; b&#39;) b)
          | XO b0 -&gt; gcdn n1 a b0
          | XH -&gt; XH)
       | XO a0 -&gt;
         (match b with
          | XI p -&gt; gcdn n1 a0 b
          | XO b0 -&gt; XO (gcdn n1 a0 b0)
          | XH -&gt; XH)
       | XH -&gt; XH)
  (** val gcd : positive -&gt; positive -&gt; positive **)
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  (** val ggcdn :
      nat -&gt; positive -&gt; positive -&gt; (positive, (positive, positive) prod)
      prod **)
  let rec ggcdn n0 a b =
    match n0 with
    | O -&gt; Pair (XH, (Pair (a, b)))
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; Pair (a, (Pair (XH, XH)))
             | Lt -&gt;
               let Pair (g, p) = ggcdn n1 (sub b&#39; a&#39;) a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt -&gt;
               let Pair (g, p) = ggcdn n1 (sub a&#39; b&#39;) b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 -&gt;
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XO a0 -&gt;
         (match b with
          | XI p -&gt;
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -&gt; let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XH -&gt; Pair (XH, (Pair (XH, b))))
  (** val ggcd :
      positive -&gt; positive -&gt; (positive, (positive, positive) prod) prod **)
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  (** val coq_Nsucc_double : n -&gt; n **)
  let coq_Nsucc_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val coq_Ndouble : n -&gt; n **)
  let coq_Ndouble = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val coq_lor : positive -&gt; positive -&gt; positive **)
  let rec coq_lor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XI (coq_lor p0 q0)
       | XH -&gt; p)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XO (coq_lor p0 q0)
       | XH -&gt; XI p0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; XI q0
       | _ -&gt; q)
  (** val coq_land : positive -&gt; positive -&gt; n **)
  let rec coq_land p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; Npos XH)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; N0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; N0
       | _ -&gt; Npos XH)
  (** val ldiff : positive -&gt; positive -&gt; n **)
  let rec ldiff p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (ldiff p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XH -&gt; Npos p)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; Npos XH
       | _ -&gt; N0)
  (** val coq_lxor : positive -&gt; positive -&gt; n **)
  let rec coq_lxor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XH -&gt; Npos (XI p0))
    | XH -&gt;
      (match q with
       | XI q0 -&gt; Npos (XO q0)
       | XO q0 -&gt; Npos (XI q0)
       | XH -&gt; N0)
  (** val shiftl_nat : positive -&gt; nat -&gt; positive **)
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -&gt; XO x) p
  (** val shiftr_nat : positive -&gt; nat -&gt; positive **)
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  (** val shiftl : positive -&gt; n -&gt; positive **)
  let shiftl p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 (fun x -&gt; XO x) p
  (** val shiftr : positive -&gt; n -&gt; positive **)
  let shiftr p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 div2 p
  (** val testbit_nat : positive -&gt; nat -&gt; bool **)
  let rec testbit_nat p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | O -&gt; True
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XO p0 -&gt;
      (match n0 with
       | O -&gt; False
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XH -&gt;
      (match n0 with
       | O -&gt; True
       | S n1 -&gt; False)
  (** val testbit : positive -&gt; n -&gt; bool **)
  let rec testbit p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XO p0 -&gt;
      (match n0 with
       | N0 -&gt; False
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XH -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos p0 -&gt; False)
  (** val iter_op : (&#39;a1 -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter_op op p a =
    match p with
    | XI p0 -&gt; op a (iter_op op p0 (op a a))
    | XO p0 -&gt; iter_op op p0 (op a a)
    | XH -&gt; a
  (** val to_nat : positive -&gt; nat **)
  let to_nat x =
    iter_op plus x (S O)
  (** val of_nat : nat -&gt; positive **)
  let rec of_nat = function
  | O -&gt; XH
  | S x -&gt;
    (match x with
     | O -&gt; XH
     | S n1 -&gt; succ (of_nat x))
  (** val of_succ_nat : nat -&gt; positive **)
  let rec of_succ_nat = function
  | O -&gt; XH
  | S x -&gt; succ (of_succ_nat x)
  (** val eq_dec : positive -&gt; positive -&gt; sumbool **)
  let rec eq_dec p y0 =
    match p with
    | XI p0 -&gt;
      (match y0 with
       | XI p1 -&gt; eq_dec p0 p1
       | _ -&gt; Right)
    | XO p0 -&gt;
      (match y0 with
       | XO p1 -&gt; eq_dec p0 p1
       | _ -&gt; Right)
    | XH -&gt;
      (match y0 with
       | XH -&gt; Left
       | _ -&gt; Right)
  (** val peano_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 **)
  let rec peano_rect a f p =
    let f2 = peano_rect (f XH a) (fun p0 x -&gt; f (succ (XO p0)) (f (XO p0) x))
    in
    (match p with
     | XI q -&gt; f (XO q) (f2 q)
     | XO q -&gt; f2 q
     | XH -&gt; a)
  (** val peano_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 **)
  let peano_rec =
    peano_rect
  type coq_PeanoView =
  | PeanoOne
  | PeanoSucc of positive * coq_PeanoView
  (** val coq_PeanoView_rect :
      &#39;a1 -&gt; (positive -&gt; coq_PeanoView -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt;
      coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_rect f f0 p = function
  | PeanoOne -&gt; f
  | PeanoSucc (p1, p2) -&gt; f0 p1 p2 (coq_PeanoView_rect f f0 p1 p2)
  (** val coq_PeanoView_rec :
      &#39;a1 -&gt; (positive -&gt; coq_PeanoView -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt;
      coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_rec f f0 p = function
  | PeanoOne -&gt; f
  | PeanoSucc (p1, p2) -&gt; f0 p1 p2 (coq_PeanoView_rec f f0 p1 p2)
  (** val peanoView_xO : positive -&gt; coq_PeanoView -&gt; coq_PeanoView **)
  let rec peanoView_xO p = function
  | PeanoOne -&gt; PeanoSucc (XH, PeanoOne)
  | PeanoSucc (p0, q0) -&gt;
    PeanoSucc ((succ (XO p0)), (PeanoSucc ((XO p0), (peanoView_xO p0 q0))))
  (** val peanoView_xI : positive -&gt; coq_PeanoView -&gt; coq_PeanoView **)
  let rec peanoView_xI p = function
  | PeanoOne -&gt; PeanoSucc ((succ XH), (PeanoSucc (XH, PeanoOne)))
  | PeanoSucc (p0, q0) -&gt;
    PeanoSucc ((succ (XI p0)), (PeanoSucc ((XI p0), (peanoView_xI p0 q0))))
  (** val peanoView : positive -&gt; coq_PeanoView **)
  let rec peanoView = function
  | XI p0 -&gt; peanoView_xI p0 (peanoView p0)
  | XO p0 -&gt; peanoView_xO p0 (peanoView p0)
  | XH -&gt; PeanoOne
  (** val coq_PeanoView_iter :
      &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_iter a f p = function
  | PeanoOne -&gt; a
  | PeanoSucc (p0, q0) -&gt; f p0 (coq_PeanoView_iter a f p0 q0)
  (** val eqb_spec : positive -&gt; positive -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val switch_Eq : comparison -&gt; comparison -&gt; comparison **)
  let switch_Eq c = function
  | Eq -&gt; c
  | x -&gt; x
  (** val mask2cmp : mask -&gt; comparison **)
  let mask2cmp = function
  | IsNul -&gt; Eq
  | IsPos p0 -&gt; Gt
  | IsNeg -&gt; Lt
  (** val leb_spec0 : positive -&gt; positive -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : positive -&gt; positive -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : positive -&gt; positive -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : positive -&gt; positive -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong :
      positive -&gt; positive -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : positive -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : positive -&gt; positive -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong :
      positive -&gt; positive -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : positive -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : positive -&gt; positive -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module N = 
 struct 
  type t = n
  (** val zero : n **)
  let zero =
    N0
  (** val one : n **)
  let one =
    Npos XH
  (** val two : n **)
  let two =
    Npos (XO XH)
  (** val succ_double : n -&gt; n **)
  let succ_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val double : n -&gt; n **)
  let double = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val succ : n -&gt; n **)
  let succ = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (Coq_Pos.succ p)
  (** val pred : n -&gt; n **)
  let pred = function
  | N0 -&gt; N0
  | Npos p -&gt; Coq_Pos.pred_N p
  (** val succ_pos : n -&gt; positive **)
  let succ_pos = function
  | N0 -&gt; XH
  | Npos p -&gt; Coq_Pos.succ p
  (** val add : n -&gt; n -&gt; n **)
  let add n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Npos (Coq_Pos.add p q))
  (** val sub : n -&gt; n -&gt; n **)
  let sub n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos n&#39; -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos m&#39; -&gt;
         (match Coq_Pos.sub_mask n&#39; m&#39; with
          | Coq_Pos.IsPos p -&gt; Npos p
          | _ -&gt; N0))
  (** val mul : n -&gt; n -&gt; n **)
  let mul n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; N0
       | Npos q -&gt; Npos (Coq_Pos.mul p q))
  (** val compare : n -&gt; n -&gt; comparison **)
  let compare n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; Eq
       | Npos m&#39; -&gt; Lt)
    | Npos n&#39; -&gt;
      (match m with
       | N0 -&gt; Gt
       | Npos m&#39; -&gt; Coq_Pos.compare n&#39; m&#39;)
  (** val eqb : n -&gt; n -&gt; bool **)
  let rec eqb n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; True
       | Npos p -&gt; False)
    | Npos p -&gt;
      (match m with
       | N0 -&gt; False
       | Npos q -&gt; Coq_Pos.eqb p q)
  (** val leb : n -&gt; n -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : n -&gt; n -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val min : n -&gt; n -&gt; n **)
  let min n0 n&#39; =
    match compare n0 n&#39; with
    | Gt -&gt; n&#39;
    | _ -&gt; n0
  (** val max : n -&gt; n -&gt; n **)
  let max n0 n&#39; =
    match compare n0 n&#39; with
    | Gt -&gt; n0
    | _ -&gt; n&#39;
  (** val div2 : n -&gt; n **)
  let div2 = function
  | N0 -&gt; N0
  | Npos p0 -&gt;
    (match p0 with
     | XI p -&gt; Npos p
     | XO p -&gt; Npos p
     | XH -&gt; N0)
  (** val even : n -&gt; bool **)
  let even = function
  | N0 -&gt; True
  | Npos p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  (** val odd : n -&gt; bool **)
  let odd n0 =
    negb (even n0)
  (** val pow : n -&gt; n -&gt; n **)
  let pow n0 = function
  | N0 -&gt; Npos XH
  | Npos p0 -&gt;
    (match n0 with
     | N0 -&gt; N0
     | Npos q -&gt; Npos (Coq_Pos.pow q p0))
  (** val square : n -&gt; n **)
  let square = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.square p)
  (** val log2 : n -&gt; n **)
  let log2 = function
  | N0 -&gt; N0
  | Npos p0 -&gt;
    (match p0 with
     | XI p -&gt; Npos (Coq_Pos.size p)
     | XO p -&gt; Npos (Coq_Pos.size p)
     | XH -&gt; N0)
  (** val size : n -&gt; n **)
  let size = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.size p)
  (** val size_nat : n -&gt; nat **)
  let size_nat = function
  | N0 -&gt; O
  | Npos p -&gt; Coq_Pos.size_nat p
  (** val pos_div_eucl : positive -&gt; n -&gt; (n, n) prod **)
  let rec pos_div_eucl a b =
    match a with
    | XI a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = succ_double r in
      (match leb b r&#39; with
       | True -&gt; Pair ((succ_double q), (sub r&#39; b))
       | False -&gt; Pair ((double q), r&#39;))
    | XO a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = double r in
      (match leb b r&#39; with
       | True -&gt; Pair ((succ_double q), (sub r&#39; b))
       | False -&gt; Pair ((double q), r&#39;))
    | XH -&gt;
      (match b with
       | N0 -&gt; Pair (N0, (Npos XH))
       | Npos p -&gt;
         (match p with
          | XH -&gt; Pair ((Npos XH), N0)
          | _ -&gt; Pair (N0, (Npos XH))))
  (** val div_eucl : n -&gt; n -&gt; (n, n) prod **)
  let div_eucl a b =
    match a with
    | N0 -&gt; Pair (N0, N0)
    | Npos na -&gt;
      (match b with
       | N0 -&gt; Pair (N0, a)
       | Npos p -&gt; pos_div_eucl na b)
  (** val div : n -&gt; n -&gt; n **)
  let div a b =
    fst (div_eucl a b)
  (** val modulo : n -&gt; n -&gt; n **)
  let modulo a b =
    snd (div_eucl a b)
  (** val gcd : n -&gt; n -&gt; n **)
  let gcd a b =
    match a with
    | N0 -&gt; b
    | Npos p -&gt;
      (match b with
       | N0 -&gt; a
       | Npos q -&gt; Npos (Coq_Pos.gcd p q))
  (** val ggcd : n -&gt; n -&gt; (n, (n, n) prod) prod **)
  let ggcd a b =
    match a with
    | N0 -&gt; Pair (b, (Pair (N0, (Npos XH))))
    | Npos p -&gt;
      (match b with
       | N0 -&gt; Pair (a, (Pair ((Npos XH), N0)))
       | Npos q -&gt;
         let Pair (g, p0) = Coq_Pos.ggcd p q in
         let Pair (aa, bb) = p0 in
         Pair ((Npos g), (Pair ((Npos aa), (Npos bb)))))
  (** val sqrtrem : n -&gt; (n, n) prod **)
  let sqrtrem = function
  | N0 -&gt; Pair (N0, N0)
  | Npos p -&gt;
    let Pair (s, m) = Coq_Pos.sqrtrem p in
    (match m with
     | Coq_Pos.IsPos r -&gt; Pair ((Npos s), (Npos r))
     | _ -&gt; Pair ((Npos s), N0))
  (** val sqrt : n -&gt; n **)
  let sqrt = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.sqrt p)
  (** val coq_lor : n -&gt; n -&gt; n **)
  let coq_lor n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Npos (Coq_Pos.coq_lor p q))
  (** val coq_land : n -&gt; n -&gt; n **)
  let coq_land n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; N0
       | Npos q -&gt; Coq_Pos.coq_land p q)
  (** val ldiff : n -&gt; n -&gt; n **)
  let rec ldiff n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Coq_Pos.ldiff p q)
  (** val coq_lxor : n -&gt; n -&gt; n **)
  let coq_lxor n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Coq_Pos.coq_lxor p q)
  (** val shiftl_nat : n -&gt; nat -&gt; n **)
  let shiftl_nat a n0 =
    nat_iter n0 double a
  (** val shiftr_nat : n -&gt; nat -&gt; n **)
  let shiftr_nat a n0 =
    nat_iter n0 div2 a
  (** val shiftl : n -&gt; n -&gt; n **)
  let shiftl a n0 =
    match a with
    | N0 -&gt; N0
    | Npos a0 -&gt; Npos (Coq_Pos.shiftl a0 n0)
  (** val shiftr : n -&gt; n -&gt; n **)
  let shiftr a = function
  | N0 -&gt; a
  | Npos p -&gt; Coq_Pos.iter p div2 a
  (** val testbit_nat : n -&gt; nat -&gt; bool **)
  let testbit_nat = function
  | N0 -&gt; (fun x -&gt; False)
  | Npos p -&gt; Coq_Pos.testbit_nat p
  (** val testbit : n -&gt; n -&gt; bool **)
  let testbit a n0 =
    match a with
    | N0 -&gt; False
    | Npos p -&gt; Coq_Pos.testbit p n0
  (** val to_nat : n -&gt; nat **)
  let to_nat = function
  | N0 -&gt; O
  | Npos p -&gt; Coq_Pos.to_nat p
  (** val of_nat : nat -&gt; n **)
  let of_nat = function
  | O -&gt; N0
  | S n&#39; -&gt; Npos (Coq_Pos.of_succ_nat n&#39;)
  (** val iter : n -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let iter n0 f x =
    match n0 with
    | N0 -&gt; x
    | Npos p -&gt; Coq_Pos.iter p f x
  (** val eq_dec : n -&gt; n -&gt; sumbool **)
  let eq_dec n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; Left
       | Npos p -&gt; Right)
    | Npos x -&gt;
      (match m with
       | N0 -&gt; Right
       | Npos p0 -&gt; Coq_Pos.eq_dec x p0)
  (** val discr : n -&gt; positive sumor **)
  let discr = function
  | N0 -&gt; Inright
  | Npos p -&gt; Inleft p
  (** val binary_rect :
      &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let binary_rect f0 f2 fS2 n0 =
    let f2&#39; = fun p -&gt; f2 (Npos p) in
    let fS2&#39; = fun p -&gt; fS2 (Npos p) in
    (match n0 with
     | N0 -&gt; f0
     | Npos p -&gt;
       let rec f = function
       | XI p1 -&gt; fS2&#39; p1 (f p1)
       | XO p1 -&gt; f2&#39; p1 (f p1)
       | XH -&gt; fS2 N0 f0
       in f p)
  (** val binary_rec :
      &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let binary_rec =
    binary_rect
  (** val peano_rect : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let peano_rect f0 f n0 =
    let f&#39; = fun p -&gt; f (Npos p) in
    (match n0 with
     | N0 -&gt; f0
     | Npos p -&gt; Coq_Pos.peano_rect (f N0 f0) f&#39; p)
  (** val peano_rec : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let peano_rec =
    peano_rect
  (** val leb_spec0 : n -&gt; n -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : n -&gt; n -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_BootStrap = 
   struct 
   end
  (** val recursion : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let recursion x =
    peano_rect x
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
     end
    module Tac = 
     struct 
     end
   end
  module Private_NZPow = 
   struct 
   end
  module Private_NZSqrt = 
   struct 
   end
  (** val sqrt_up : n -&gt; n **)
  let sqrt_up a =
    match compare N0 a with
    | Lt -&gt; succ (sqrt (pred a))
    | _ -&gt; N0
  (** val log2_up : n -&gt; n **)
  let log2_up a =
    match compare (Npos XH) a with
    | Lt -&gt; succ (log2 (pred a))
    | _ -&gt; N0
  module Private_NZDiv = 
   struct 
   end
  (** val lcm : n -&gt; n -&gt; n **)
  let lcm a b =
    mul a (div b (gcd a b))
  (** val eqb_spec : n -&gt; n -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val b2n : bool -&gt; n **)
  let b2n = function
  | True -&gt; Npos XH
  | False -&gt; N0
  (** val setbit : n -&gt; n -&gt; n **)
  let setbit a n0 =
    coq_lor a (shiftl (Npos XH) n0)
  (** val clearbit : n -&gt; n -&gt; n **)
  let clearbit a n0 =
    ldiff a (shiftl (Npos XH) n0)
  (** val ones : n -&gt; n **)
  let ones n0 =
    pred (shiftl (Npos XH) n0)
  (** val lnot : n -&gt; n -&gt; n **)
  let lnot a n0 =
    coq_lxor a (ones n0)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : n -&gt; n -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : n -&gt; n -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong : n -&gt; n -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : n -&gt; n -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : n -&gt; n -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong : n -&gt; n -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : n -&gt; n -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : n -&gt; n -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module Z = 
 struct 
  type t = z
  (** val zero : z **)
  let zero =
    Z0
  (** val one : z **)
  let one =
    Zpos XH
  (** val two : z **)
  let two =
    Zpos (XO XH)
  (** val double : z -&gt; z **)
  let double = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos (XO p)
  | Zneg p -&gt; Zneg (XO p)
  (** val succ_double : z -&gt; z **)
  let succ_double = function
  | Z0 -&gt; Zpos XH
  | Zpos p -&gt; Zpos (XI p)
  | Zneg p -&gt; Zneg (Coq_Pos.pred_double p)
  (** val pred_double : z -&gt; z **)
  let pred_double = function
  | Z0 -&gt; Zneg XH
  | Zpos p -&gt; Zpos (Coq_Pos.pred_double p)
  | Zneg p -&gt; Zneg (XI p)
  (** val pos_sub : positive -&gt; positive -&gt; z **)
  let rec pos_sub x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double (pos_sub p q)
       | XO q -&gt; succ_double (pos_sub p q)
       | XH -&gt; Zpos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; pred_double (pos_sub p q)
       | XO q -&gt; double (pos_sub p q)
       | XH -&gt; Zpos (Coq_Pos.pred_double p))
    | XH -&gt;
      (match y with
       | XI q -&gt; Zneg (XO q)
       | XO q -&gt; Zneg (Coq_Pos.pred_double q)
       | XH -&gt; Z0)
  (** val add : z -&gt; z -&gt; z **)
  let add x y =
    match x with
    | Z0 -&gt; y
    | Zpos x&#39; -&gt;
      (match y with
       | Z0 -&gt; x
       | Zpos y&#39; -&gt; Zpos (Coq_Pos.add x&#39; y&#39;)
       | Zneg y&#39; -&gt; pos_sub x&#39; y&#39;)
    | Zneg x&#39; -&gt;
      (match y with
       | Z0 -&gt; x
       | Zpos y&#39; -&gt; pos_sub y&#39; x&#39;
       | Zneg y&#39; -&gt; Zneg (Coq_Pos.add x&#39; y&#39;))
  (** val opp : z -&gt; z **)
  let opp = function
  | Z0 -&gt; Z0
  | Zpos x0 -&gt; Zneg x0
  | Zneg x0 -&gt; Zpos x0
  (** val succ : z -&gt; z **)
  let succ x =
    add x (Zpos XH)
  (** val pred : z -&gt; z **)
  let pred x =
    add x (Zneg XH)
  (** val sub : z -&gt; z -&gt; z **)
  let sub m n0 =
    add m (opp n0)
  (** val mul : z -&gt; z -&gt; z **)
  let mul x y =
    match x with
    | Z0 -&gt; Z0
    | Zpos x&#39; -&gt;
      (match y with
       | Z0 -&gt; Z0
       | Zpos y&#39; -&gt; Zpos (Coq_Pos.mul x&#39; y&#39;)
       | Zneg y&#39; -&gt; Zneg (Coq_Pos.mul x&#39; y&#39;))
    | Zneg x&#39; -&gt;
      (match y with
       | Z0 -&gt; Z0
       | Zpos y&#39; -&gt; Zneg (Coq_Pos.mul x&#39; y&#39;)
       | Zneg y&#39; -&gt; Zpos (Coq_Pos.mul x&#39; y&#39;))
  (** val pow_pos : z -&gt; positive -&gt; z **)
  let pow_pos z0 n0 =
    Coq_Pos.iter n0 (mul z0) (Zpos XH)
  (** val pow : z -&gt; z -&gt; z **)
  let pow x = function
  | Z0 -&gt; Zpos XH
  | Zpos p -&gt; pow_pos x p
  | Zneg p -&gt; Z0
  (** val square : z -&gt; z **)
  let square = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos (Coq_Pos.square p)
  | Zneg p -&gt; Zpos (Coq_Pos.square p)
  (** val compare : z -&gt; z -&gt; comparison **)
  let compare x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; Eq
       | Zpos y&#39; -&gt; Lt
       | Zneg y&#39; -&gt; Gt)
    | Zpos x&#39; -&gt;
      (match y with
       | Zpos y&#39; -&gt; Coq_Pos.compare x&#39; y&#39;
       | _ -&gt; Gt)
    | Zneg x&#39; -&gt;
      (match y with
       | Zneg y&#39; -&gt; compOpp (Coq_Pos.compare x&#39; y&#39;)
       | _ -&gt; Lt)
  (** val sgn : z -&gt; z **)
  let sgn = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos XH
  | Zneg p -&gt; Zneg XH
  (** val leb : z -&gt; z -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : z -&gt; z -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val geb : z -&gt; z -&gt; bool **)
  let geb x y =
    match compare x y with
    | Lt -&gt; False
    | _ -&gt; True
  (** val gtb : z -&gt; z -&gt; bool **)
  let gtb x y =
    match compare x y with
    | Gt -&gt; True
    | _ -&gt; False
  (** val eqb : z -&gt; z -&gt; bool **)
  let rec eqb x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; True
       | _ -&gt; False)
    | Zpos p -&gt;
      (match y with
       | Zpos q -&gt; Coq_Pos.eqb p q
       | _ -&gt; False)
    | Zneg p -&gt;
      (match y with
       | Zneg q -&gt; Coq_Pos.eqb p q
       | _ -&gt; False)
  (** val max : z -&gt; z -&gt; z **)
  let max n0 m =
    match compare n0 m with
    | Lt -&gt; m
    | _ -&gt; n0
  (** val min : z -&gt; z -&gt; z **)
  let min n0 m =
    match compare n0 m with
    | Gt -&gt; m
    | _ -&gt; n0
  (** val abs : z -&gt; z **)
  let abs = function
  | Zneg p -&gt; Zpos p
  | x -&gt; x
  (** val abs_nat : z -&gt; nat **)
  let abs_nat = function
  | Z0 -&gt; O
  | Zpos p -&gt; Coq_Pos.to_nat p
  | Zneg p -&gt; Coq_Pos.to_nat p
  (** val abs_N : z -&gt; n **)
  let abs_N = function
  | Z0 -&gt; N0
  | Zpos p -&gt; Npos p
  | Zneg p -&gt; Npos p
  (** val to_nat : z -&gt; nat **)
  let to_nat = function
  | Zpos p -&gt; Coq_Pos.to_nat p
  | _ -&gt; O
  (** val to_N : z -&gt; n **)
  let to_N = function
  | Zpos p -&gt; Npos p
  | _ -&gt; N0
  (** val of_nat : nat -&gt; z **)
  let of_nat = function
  | O -&gt; Z0
  | S n1 -&gt; Zpos (Coq_Pos.of_succ_nat n1)
  (** val of_N : n -&gt; z **)
  let of_N = function
  | N0 -&gt; Z0
  | Npos p -&gt; Zpos p
  (** val to_pos : z -&gt; positive **)
  let to_pos = function
  | Zpos p -&gt; p
  | _ -&gt; XH
  (** val iter : z -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let iter n0 f x =
    match n0 with
    | Zpos p -&gt; Coq_Pos.iter p f x
    | _ -&gt; x
  (** val pos_div_eucl : positive -&gt; z -&gt; (z, z) prod **)
  let rec pos_div_eucl a b =
    match a with
    | XI a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = add (mul (Zpos (XO XH)) r) (Zpos XH) in
      (match ltb r&#39; b with
       | True -&gt; Pair ((mul (Zpos (XO XH)) q), r&#39;)
       | False -&gt; Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r&#39; b)))
    | XO a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = mul (Zpos (XO XH)) r in
      (match ltb r&#39; b with
       | True -&gt; Pair ((mul (Zpos (XO XH)) q), r&#39;)
       | False -&gt; Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r&#39; b)))
    | XH -&gt;
      (match leb (Zpos (XO XH)) b with
       | True -&gt; Pair (Z0, (Zpos XH))
       | False -&gt; Pair ((Zpos XH), Z0))
  (** val div_eucl : z -&gt; z -&gt; (z, z) prod **)
  let div_eucl a b =
    match a with
    | Z0 -&gt; Pair (Z0, Z0)
    | Zpos a&#39; -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, Z0)
       | Zpos p -&gt; pos_div_eucl a&#39; b
       | Zneg b&#39; -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; (Zpos b&#39;) in
         (match r with
          | Z0 -&gt; Pair ((opp q), Z0)
          | _ -&gt; Pair ((opp (add q (Zpos XH))), (add b r))))
    | Zneg a&#39; -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, Z0)
       | Zpos p -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; b in
         (match r with
          | Z0 -&gt; Pair ((opp q), Z0)
          | _ -&gt; Pair ((opp (add q (Zpos XH))), (sub b r)))
       | Zneg b&#39; -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; (Zpos b&#39;) in Pair (q, (opp r)))
  (** val div : z -&gt; z -&gt; z **)
  let div a b =
    let Pair (q, x) = div_eucl a b in q
  (** val modulo : z -&gt; z -&gt; z **)
  let modulo a b =
    let Pair (x, r) = div_eucl a b in r
  (** val quotrem : z -&gt; z -&gt; (z, z) prod **)
  let quotrem a b =
    match a with
    | Z0 -&gt; Pair (Z0, Z0)
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, a)
       | Zpos b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (of_N r))
       | Zneg b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (of_N r)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, a)
       | Zpos b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (opp (of_N r)))
       | Zneg b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (opp (of_N r))))
  (** val quot : z -&gt; z -&gt; z **)
  let quot a b =
    fst (quotrem a b)
  (** val rem : z -&gt; z -&gt; z **)
  let rem a b =
    snd (quotrem a b)
  (** val even : z -&gt; bool **)
  let even = function
  | Z0 -&gt; True
  | Zpos p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  | Zneg p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  (** val odd : z -&gt; bool **)
  let odd = function
  | Z0 -&gt; False
  | Zpos p -&gt;
    (match p with
     | XO p0 -&gt; False
     | _ -&gt; True)
  | Zneg p -&gt;
    (match p with
     | XO p0 -&gt; False
     | _ -&gt; True)
  (** val div2 : z -&gt; z **)
  let div2 = function
  | Z0 -&gt; Z0
  | Zpos p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zpos (Coq_Pos.div2 p))
  | Zneg p -&gt; Zneg (Coq_Pos.div2_up p)
  (** val quot2 : z -&gt; z **)
  let quot2 = function
  | Z0 -&gt; Z0
  | Zpos p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zpos (Coq_Pos.div2 p))
  | Zneg p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zneg (Coq_Pos.div2 p))
  (** val log2 : z -&gt; z **)
  let log2 = function
  | Zpos p0 -&gt;
    (match p0 with
     | XI p -&gt; Zpos (Coq_Pos.size p)
     | XO p -&gt; Zpos (Coq_Pos.size p)
     | XH -&gt; Z0)
  | _ -&gt; Z0
  (** val sqrtrem : z -&gt; (z, z) prod **)
  let sqrtrem = function
  | Zpos p -&gt;
    let Pair (s, m) = Coq_Pos.sqrtrem p in
    (match m with
     | Coq_Pos.IsPos r -&gt; Pair ((Zpos s), (Zpos r))
     | _ -&gt; Pair ((Zpos s), Z0))
  | _ -&gt; Pair (Z0, Z0)
  (** val sqrt : z -&gt; z **)
  let sqrt = function
  | Zpos p -&gt; Zpos (Coq_Pos.sqrt p)
  | _ -&gt; Z0
  (** val gcd : z -&gt; z -&gt; z **)
  let gcd a b =
    match a with
    | Z0 -&gt; abs b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; abs a
       | Zpos b0 -&gt; Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -&gt; Zpos (Coq_Pos.gcd a0 b0))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; abs a
       | Zpos b0 -&gt; Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -&gt; Zpos (Coq_Pos.gcd a0 b0))
  (** val ggcd : z -&gt; z -&gt; (z, (z, z) prod) prod **)
  let ggcd a b =
    match a with
    | Z0 -&gt; Pair ((abs b), (Pair (Z0, (sgn b))))
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zpos bb))))
       | Zneg b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zneg bb)))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zpos bb))))
       | Zneg b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zneg bb)))))
  (** val testbit : z -&gt; z -&gt; bool **)
  let testbit a = function
  | Z0 -&gt; odd a
  | Zpos p -&gt;
    (match a with
     | Z0 -&gt; False
     | Zpos a0 -&gt; Coq_Pos.testbit a0 (Npos p)
     | Zneg a0 -&gt; negb (N.testbit (Coq_Pos.pred_N a0) (Npos p)))
  | Zneg p -&gt; False
  (** val shiftl : z -&gt; z -&gt; z **)
  let shiftl a = function
  | Z0 -&gt; a
  | Zpos p -&gt; Coq_Pos.iter p (mul (Zpos (XO XH))) a
  | Zneg p -&gt; Coq_Pos.iter p div2 a
  (** val shiftr : z -&gt; z -&gt; z **)
  let shiftr a n0 =
    shiftl a (opp n0)
  (** val coq_lor : z -&gt; z -&gt; z **)
  let coq_lor a b =
    match a with
    | Z0 -&gt; b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; Zpos (Coq_Pos.coq_lor a0 b0)
       | Zneg b0 -&gt; Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N b0) (Npos a0))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt;
         Zneg
           (N.succ_pos (N.coq_land (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  (** val coq_land : z -&gt; z -&gt; z **)
  let coq_land a b =
    match a with
    | Z0 -&gt; Z0
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Z0
       | Zpos b0 -&gt; of_N (Coq_Pos.coq_land a0 b0)
       | Zneg b0 -&gt; of_N (N.ldiff (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Z0
       | Zpos b0 -&gt; of_N (N.ldiff (Npos b0) (Coq_Pos.pred_N a0))
       | Zneg b0 -&gt;
         Zneg
           (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  (** val ldiff : z -&gt; z -&gt; z **)
  let ldiff a b =
    match a with
    | Z0 -&gt; Z0
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; of_N (Coq_Pos.ldiff a0 b0)
       | Zneg b0 -&gt; of_N (N.coq_land (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt;
         Zneg (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt; of_N (N.ldiff (Coq_Pos.pred_N b0) (Coq_Pos.pred_N a0)))
  (** val coq_lxor : z -&gt; z -&gt; z **)
  let coq_lxor a b =
    match a with
    | Z0 -&gt; b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; of_N (Coq_Pos.coq_lxor a0 b0)
       | Zneg b0 -&gt;
         Zneg (N.succ_pos (N.coq_lxor (Npos a0) (Coq_Pos.pred_N b0))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt;
         Zneg (N.succ_pos (N.coq_lxor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt; of_N (N.coq_lxor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0)))
  (** val eq_dec : z -&gt; z -&gt; sumbool **)
  let eq_dec x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; Left
       | _ -&gt; Right)
    | Zpos x0 -&gt;
      (match y with
       | Zpos p0 -&gt; Coq_Pos.eq_dec x0 p0
       | _ -&gt; Right)
    | Zneg x0 -&gt;
      (match y with
       | Zneg p0 -&gt; Coq_Pos.eq_dec x0 p0
       | _ -&gt; Right)
  module Private_BootStrap = 
   struct 
   end
  (** val leb_spec0 : z -&gt; z -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : z -&gt; z -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
     end
    module Tac = 
     struct 
     end
   end
  (** val sqrt_up : z -&gt; z **)
  let sqrt_up a =
    match compare Z0 a with
    | Lt -&gt; succ (sqrt (pred a))
    | _ -&gt; Z0
  (** val log2_up : z -&gt; z **)
  let log2_up a =
    match compare (Zpos XH) a with
    | Lt -&gt; succ (log2 (pred a))
    | _ -&gt; Z0
  module Private_NZDiv = 
   struct 
   end
  module Private_Div = 
   struct 
    module Quot2Div = 
     struct 
      (** val div : z -&gt; z -&gt; z **)
      let div =
        quot
      (** val modulo : z -&gt; z -&gt; z **)
      let modulo =
        rem
     end
    module NZQuot = 
     struct 
     end
   end
  (** val lcm : z -&gt; z -&gt; z **)
  let lcm a b =
    abs (mul a (div b (gcd a b)))
  (** val eqb_spec : z -&gt; z -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val b2z : bool -&gt; z **)
  let b2z = function
  | True -&gt; Zpos XH
  | False -&gt; Z0
  (** val setbit : z -&gt; z -&gt; z **)
  let setbit a n0 =
    coq_lor a (shiftl (Zpos XH) n0)
  (** val clearbit : z -&gt; z -&gt; z **)
  let clearbit a n0 =
    ldiff a (shiftl (Zpos XH) n0)
  (** val lnot : z -&gt; z **)
  let lnot a =
    pred (opp a)
  (** val ones : z -&gt; z **)
  let ones n0 =
    pred (shiftl (Zpos XH) n0)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : z -&gt; z -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : z -&gt; z -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong : z -&gt; z -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : z -&gt; z -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : z -&gt; z -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong : z -&gt; z -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : z -&gt; z -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : z -&gt; z -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
(** val z_gt_dec : z -&gt; z -&gt; sumbool **)
let z_gt_dec x y =
  match Z.compare x y with
  | Gt -&gt; Left
  | _ -&gt; Right
(** val z_ge_dec : z -&gt; z -&gt; sumbool **)
let z_ge_dec x y =
  match Z.compare x y with
  | Lt -&gt; Right
  | _ -&gt; Left
(** val z_gt_le_dec : z -&gt; z -&gt; sumbool **)
let z_gt_le_dec x y =
  z_gt_dec x y
(** val z_ge_lt_dec : z -&gt; z -&gt; sumbool **)
let z_ge_lt_dec x y =
  z_ge_dec x y
module Z_as_OT = 
 struct 
  type t = z
  (** val compare : z -&gt; z -&gt; z compare0 **)
  let compare x y =
    match Z.compare x y with
    | Eq -&gt; EQ
    | Lt -&gt; LT
    | Gt -&gt; GT
  (** val eq_dec : z -&gt; z -&gt; sumbool **)
  let eq_dec =
    Z.eq_dec
 end
module MakeListOrdering = 
 functor (O:OrderedType) -&gt;
 struct 
  module MO = OrderedTypeFacts(O)
 end
module type OrderedTypeOrig = 
 Coq_OrderedType
module Update_OT = 
 functor (O:OrderedTypeOrig) -&gt;
 struct 
  type t = O.t
  (** val eq_dec : t -&gt; t -&gt; sumbool **)
  let eq_dec =
    O.eq_dec
  (** val compare : O.t -&gt; O.t -&gt; comparison **)
  let compare x y =
    match O.compare x y with
    | LT -&gt; Lt
    | EQ -&gt; Eq
    | GT -&gt; Gt
 end
module type Int = 
 sig 
  type t 
  val i2z : t -&gt; z
  val _0 : t
  val _1 : t
  val _2 : t
  val _3 : t
  val plus : t -&gt; t -&gt; t
  val opp : t -&gt; t
  val minus : t -&gt; t -&gt; t
  val mult : t -&gt; t -&gt; t
  val max : t -&gt; t -&gt; t
  val gt_le_dec : t -&gt; t -&gt; sumbool
  val ge_lt_dec : t -&gt; t -&gt; sumbool
  val eq_dec : t -&gt; t -&gt; sumbool
 end
module Z_as_Int = 
 struct 
  type t = z
  (** val _0 : z **)
  let _0 =
    Z0
  (** val _1 : z **)
  let _1 =
    Zpos XH
  (** val _2 : z **)
  let _2 =
    Zpos (XO XH)
  (** val _3 : z **)
  let _3 =
    Zpos (XI XH)
  (** val plus : z -&gt; z -&gt; z **)
  let plus =
    Z.add
  (** val opp : z -&gt; z **)
  let opp =
    Z.opp
  (** val minus : z -&gt; z -&gt; z **)
  let minus =
    Z.sub
  (** val mult : z -&gt; z -&gt; z **)
  let mult =
    Z.mul
  (** val max : z -&gt; z -&gt; z **)
  let max =
    Z.max
  (** val gt_le_dec : z -&gt; z -&gt; sumbool **)
  let gt_le_dec =
    z_gt_le_dec
  (** val ge_lt_dec : z -&gt; z -&gt; sumbool **)
  let ge_lt_dec =
    z_ge_lt_dec
  (** val eq_dec : z -&gt; z -&gt; sumbool **)
  let eq_dec =
    Z.eq_dec
  (** val i2z : t -&gt; z **)
  let i2z n0 =
    n0
 end
module MakeRaw = 
 functor (I:Int) -&gt;
 functor (X:OrderedType) -&gt;
 struct 
  type elt = X.t
  type tree =
  | Leaf
  | Node of I.t * tree * X.t * tree
  (** val empty : tree **)
  let empty =
    Leaf
  (** val is_empty : tree -&gt; bool **)
  let is_empty = function
  | Leaf -&gt; True
  | Node (t1, t2, t3, t4) -&gt; False
  (** val mem : X.t -&gt; tree -&gt; bool **)
  let rec mem x = function
  | Leaf -&gt; False
  | Node (t1, l, k, r) -&gt;
    (match X.compare x k with
     | Eq -&gt; True
     | Lt -&gt; mem x l
     | Gt -&gt; mem x r)
  (** val min_elt : tree -&gt; elt option **)
  let rec min_elt = function
  | Leaf -&gt; None
  | Node (t1, l, x, r) -&gt;
    (match l with
     | Leaf -&gt; Some x
     | Node (t2, t3, t4, t5) -&gt; min_elt l)
  (** val max_elt : tree -&gt; elt option **)
  let rec max_elt = function
  | Leaf -&gt; None
  | Node (t1, l, x, r) -&gt;
    (match r with
     | Leaf -&gt; Some x
     | Node (t2, t3, t4, t5) -&gt; max_elt r)
  (** val choose : tree -&gt; elt option **)
  let choose =
    min_elt
  (** val fold : (elt -&gt; &#39;a1 -&gt; &#39;a1) -&gt; tree -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec fold f t0 base =
    match t0 with
    | Leaf -&gt; base
    | Node (t1, l, x, r) -&gt; fold f r (f x (fold f l base))
  (** val elements_aux : X.t list -&gt; tree -&gt; X.t list **)
  let rec elements_aux acc = function
  | Leaf -&gt; acc
  | Node (t0, l, x, r) -&gt; elements_aux (Cons (x, (elements_aux acc r))) l
  (** val elements : tree -&gt; X.t list **)
  let elements =
    elements_aux Nil
  (** val rev_elements_aux : X.t list -&gt; tree -&gt; X.t list **)
  let rec rev_elements_aux acc = function
  | Leaf -&gt; acc
  | Node (t0, l, x, r) -&gt;
    rev_elements_aux (Cons (x, (rev_elements_aux acc l))) r
  (** val rev_elements : tree -&gt; X.t list **)
  let rev_elements =
    rev_elements_aux Nil
  (** val cardinal : tree -&gt; nat **)
  let rec cardinal = function
  | Leaf -&gt; O
  | Node (t0, l, t1, r) -&gt; S (plus (cardinal l) (cardinal r))
  (** val maxdepth : tree -&gt; nat **)
  let rec maxdepth = function
  | Leaf -&gt; O
  | Node (t0, l, t1, r) -&gt; S (max (maxdepth l) (maxdepth r))
  (** val mindepth : tree -&gt; nat **)
  let rec mindepth = function
  | Leaf -&gt; O
  | Node (t0, l, t1, r) -&gt; S (min (mindepth l) (mindepth r))
  (** val for_all : (elt -&gt; bool) -&gt; tree -&gt; bool **)
  let rec for_all f = function
  | Leaf -&gt; True
  | Node (t0, l, x, r) -&gt;
    (match match f x with
           | True -&gt; for_all f l
           | False -&gt; False with
     | True -&gt; for_all f r
     | False -&gt; False)
  (** val exists_ : (elt -&gt; bool) -&gt; tree -&gt; bool **)
  let rec exists_ f = function
  | Leaf -&gt; False
  | Node (t0, l, x, r) -&gt;
    (match match f x with
           | True -&gt; True
           | False -&gt; exists_ f l with
     | True -&gt; True
     | False -&gt; exists_ f r)
  type enumeration =
  | End
  | More of elt * tree * enumeration
  (** val cons : tree -&gt; enumeration -&gt; enumeration **)
  let rec cons s e =
    match s with
    | Leaf -&gt; e
    | Node (t0, l, x, r) -&gt; cons l (More (x, r, e))
  (** val compare_more :
      X.t -&gt; (enumeration -&gt; comparison) -&gt; enumeration -&gt; comparison **)
  let compare_more x1 cont = function
  | End -&gt; Gt
  | More (x2, r2, e3) -&gt;
    (match X.compare x1 x2 with
     | Eq -&gt; cont (cons r2 e3)
     | x -&gt; x)
  (** val compare_cont :
      tree -&gt; (enumeration -&gt; comparison) -&gt; enumeration -&gt; comparison **)
  let rec compare_cont s1 cont e2 =
    match s1 with
    | Leaf -&gt; cont e2
    | Node (t0, l1, x1, r1) -&gt;
      compare_cont l1 (compare_more x1 (compare_cont r1 cont)) e2
  (** val compare_end : enumeration -&gt; comparison **)
  let compare_end = function
  | End -&gt; Eq
  | More (e, t0, e0) -&gt; Lt
  (** val compare : tree -&gt; tree -&gt; comparison **)
  let compare s1 s2 =
    compare_cont s1 compare_end (cons s2 End)
  (** val equal : tree -&gt; tree -&gt; bool **)
  let equal s1 s2 =
    match compare s1 s2 with
    | Eq -&gt; True
    | _ -&gt; False
  (** val subsetl : (tree -&gt; bool) -&gt; X.t -&gt; tree -&gt; bool **)
  let rec subsetl subset_l1 x1 s2 = match s2 with
  | Leaf -&gt; False
  | Node (t0, l2, x2, r2) -&gt;
    (match X.compare x1 x2 with
     | Eq -&gt; subset_l1 l2
     | Lt -&gt; subsetl subset_l1 x1 l2
     | Gt -&gt;
       (match mem x1 r2 with
        | True -&gt; subset_l1 s2
        | False -&gt; False))
  (** val subsetr : (tree -&gt; bool) -&gt; X.t -&gt; tree -&gt; bool **)
  let rec subsetr subset_r1 x1 s2 = match s2 with
  | Leaf -&gt; False
  | Node (t0, l2, x2, r2) -&gt;
    (match X.compare x1 x2 with
     | Eq -&gt; subset_r1 r2
     | Lt -&gt;
       (match mem x1 l2 with
        | True -&gt; subset_r1 s2
        | False -&gt; False)
     | Gt -&gt; subsetr subset_r1 x1 r2)
  (** val subset : tree -&gt; tree -&gt; bool **)
  let rec subset s1 s2 =
    match s1 with
    | Leaf -&gt; True
    | Node (t0, l1, x1, r1) -&gt;
      (match s2 with
       | Leaf -&gt; False
       | Node (t1, l2, x2, r2) -&gt;
         (match X.compare x1 x2 with
          | Eq -&gt;
            (match subset l1 l2 with
             | True -&gt; subset r1 r2
             | False -&gt; False)
          | Lt -&gt;
            (match subsetl (subset l1) x1 l2 with
             | True -&gt; subset r1 s2
             | False -&gt; False)
          | Gt -&gt;
            (match subsetr (subset r1) x1 r2 with
             | True -&gt; subset l1 s2
             | False -&gt; False)))
  type t = tree
  (** val height : t -&gt; I.t **)
  let height = function
  | Leaf -&gt; I._0
  | Node (h, t0, t1, t2) -&gt; h
  (** val singleton : X.t -&gt; tree **)
  let singleton x =
    Node (I._1, Leaf, x, Leaf)
  (** val create : t -&gt; X.t -&gt; t -&gt; tree **)
  let create l x r =
    Node ((I.plus (I.max (height l) (height r)) I._1), l, x, r)
  (** val assert_false : t -&gt; X.t -&gt; t -&gt; tree **)
  let assert_false =
    create
  (** val bal : t -&gt; X.t -&gt; t -&gt; tree **)
  let bal l x r =
    let hl = height l in
    let hr = height r in
    (match I.gt_le_dec hl (I.plus hr I._2) with
     | Left -&gt;
       (match l with
        | Leaf -&gt; assert_false l x r
        | Node (t0, ll, lx, lr) -&gt;
          (match I.ge_lt_dec (height ll) (height lr) with
           | Left -&gt; create ll lx (create lr x r)
           | Right -&gt;
             (match lr with
              | Leaf -&gt; assert_false l x r
              | Node (t1, lrl, lrx, lrr) -&gt;
                create (create ll lx lrl) lrx (create lrr x r))))
     | Right -&gt;
       (match I.gt_le_dec hr (I.plus hl I._2) with
        | Left -&gt;
          (match r with
           | Leaf -&gt; assert_false l x r
           | Node (t0, rl, rx, rr) -&gt;
             (match I.ge_lt_dec (height rr) (height rl) with
              | Left -&gt; create (create l x rl) rx rr
              | Right -&gt;
                (match rl with
                 | Leaf -&gt; assert_false l x r
                 | Node (t1, rll, rlx, rlr) -&gt;
                   create (create l x rll) rlx (create rlr rx rr))))
        | Right -&gt; create l x r))
  (** val add : X.t -&gt; tree -&gt; tree **)
  let rec add x = function
  | Leaf -&gt; Node (I._1, Leaf, x, Leaf)
  | Node (h, l, y, r) -&gt;
    (match X.compare x y with
     | Eq -&gt; Node (h, l, y, r)
     | Lt -&gt; bal (add x l) y r
     | Gt -&gt; bal l y (add x r))
  (** val join : tree -&gt; elt -&gt; t -&gt; t **)
  let rec join l = match l with
  | Leaf -&gt; add
  | Node (lh, ll, lx, lr) -&gt;
    (fun x -&gt;
      let rec join_aux r = match r with
      | Leaf -&gt; add x l
      | Node (rh, rl, rx, rr) -&gt;
        (match I.gt_le_dec lh (I.plus rh I._2) with
         | Left -&gt; bal ll lx (join lr x r)
         | Right -&gt;
           (match I.gt_le_dec rh (I.plus lh I._2) with
            | Left -&gt; bal (join_aux rl) rx rr
            | Right -&gt; create l x r))
      in join_aux)
  (** val remove_min : tree -&gt; elt -&gt; t -&gt; (t, elt) prod **)
  let rec remove_min l x r =
    match l with
    | Leaf -&gt; Pair (r, x)
    | Node (lh, ll, lx, lr) -&gt;
      let Pair (l&#39;, m) = remove_min ll lx lr in Pair ((bal l&#39; x r), m)
  (** val merge : tree -&gt; tree -&gt; tree **)
  let merge s1 s2 =
    match s1 with
    | Leaf -&gt; s2
    | Node (t0, t1, t2, t3) -&gt;
      (match s2 with
       | Leaf -&gt; s1
       | Node (t4, l2, x2, r2) -&gt;
         let Pair (s2&#39;, m) = remove_min l2 x2 r2 in bal s1 m s2&#39;)
  (** val remove : X.t -&gt; tree -&gt; tree **)
  let rec remove x = function
  | Leaf -&gt; Leaf
  | Node (t0, l, y, r) -&gt;
    (match X.compare x y with
     | Eq -&gt; merge l r
     | Lt -&gt; bal (remove x l) y r
     | Gt -&gt; bal l y (remove x r))
  (** val concat : tree -&gt; tree -&gt; tree **)
  let concat s1 s2 =
    match s1 with
    | Leaf -&gt; s2
    | Node (t0, t1, t2, t3) -&gt;
      (match s2 with
       | Leaf -&gt; s1
       | Node (t4, l2, x2, r2) -&gt;
         let Pair (s2&#39;, m) = remove_min l2 x2 r2 in join s1 m s2&#39;)
  type triple = { t_left : t; t_in : bool; t_right : t }
  (** val t_left : triple -&gt; t **)
  let t_left t0 =
    t0.t_left
  (** val t_in : triple -&gt; bool **)
  let t_in t0 =
    t0.t_in
  (** val t_right : triple -&gt; t **)
  let t_right t0 =
    t0.t_right
  (** val split : X.t -&gt; tree -&gt; triple **)
  let rec split x = function
  | Leaf -&gt; { t_left = Leaf; t_in = False; t_right = Leaf }
  | Node (t0, l, y, r) -&gt;
    (match X.compare x y with
     | Eq -&gt; { t_left = l; t_in = True; t_right = r }
     | Lt -&gt;
       let { t_left = ll; t_in = b; t_right = rl } = split x l in
       { t_left = ll; t_in = b; t_right = (join rl y r) }
     | Gt -&gt;
       let { t_left = rl; t_in = b; t_right = rr } = split x r in
       { t_left = (join l y rl); t_in = b; t_right = rr })
  (** val inter : tree -&gt; tree -&gt; tree **)
  let rec inter s1 s2 =
    match s1 with
    | Leaf -&gt; Leaf
    | Node (t0, l1, x1, r1) -&gt;
      (match s2 with
       | Leaf -&gt; Leaf
       | Node (t1, t2, t3, t4) -&gt;
         let { t_left = l2&#39;; t_in = pres; t_right = r2&#39; } = split x1 s2 in
         (match pres with
          | True -&gt; join (inter l1 l2&#39;) x1 (inter r1 r2&#39;)
          | False -&gt; concat (inter l1 l2&#39;) (inter r1 r2&#39;)))
  (** val diff : tree -&gt; tree -&gt; tree **)
  let rec diff s1 s2 =
    match s1 with
    | Leaf -&gt; Leaf
    | Node (t0, l1, x1, r1) -&gt;
      (match s2 with
       | Leaf -&gt; s1
       | Node (t1, t2, t3, t4) -&gt;
         let { t_left = l2&#39;; t_in = pres; t_right = r2&#39; } = split x1 s2 in
         (match pres with
          | True -&gt; concat (diff l1 l2&#39;) (diff r1 r2&#39;)
          | False -&gt; join (diff l1 l2&#39;) x1 (diff r1 r2&#39;)))
  (** val union : tree -&gt; tree -&gt; tree **)
  let rec union s1 s2 =
    match s1 with
    | Leaf -&gt; s2
    | Node (t0, l1, x1, r1) -&gt;
      (match s2 with
       | Leaf -&gt; s1
       | Node (t1, t2, t3, t4) -&gt;
         let { t_left = l2&#39;; t_in = x; t_right = r2&#39; } = split x1 s2 in
         join (union l1 l2&#39;) x1 (union r1 r2&#39;))
  (** val filter : (elt -&gt; bool) -&gt; tree -&gt; tree **)
  let rec filter f = function
  | Leaf -&gt; Leaf
  | Node (t0, l, x, r) -&gt;
    let l&#39; = filter f l in
    let r&#39; = filter f r in
    (match f x with
     | True -&gt; join l&#39; x r&#39;
     | False -&gt; concat l&#39; r&#39;)
  (** val partition : (elt -&gt; bool) -&gt; t -&gt; (t, t) prod **)
  let rec partition f = function
  | Leaf -&gt; Pair (Leaf, Leaf)
  | Node (t0, l, x, r) -&gt;
    let Pair (l1, l2) = partition f l in
    let Pair (r1, r2) = partition f r in
    (match f x with
     | True -&gt; Pair ((join l1 x r1), (concat l2 r2))
     | False -&gt; Pair ((concat l1 r1), (join l2 x r2)))
  (** val ltb_tree : X.t -&gt; tree -&gt; bool **)
  let rec ltb_tree x = function
  | Leaf -&gt; True
  | Node (t0, l, y, r) -&gt;
    (match X.compare x y with
     | Gt -&gt;
       (match ltb_tree x l with
        | True -&gt; ltb_tree x r
        | False -&gt; False)
     | _ -&gt; False)
  (** val gtb_tree : X.t -&gt; tree -&gt; bool **)
  let rec gtb_tree x = function
  | Leaf -&gt; True
  | Node (t0, l, y, r) -&gt;
    (match X.compare x y with
     | Lt -&gt;
       (match gtb_tree x l with
        | True -&gt; gtb_tree x r
        | False -&gt; False)
     | _ -&gt; False)
  (** val isok : tree -&gt; bool **)
  let rec isok = function
  | Leaf -&gt; True
  | Node (t0, l, x, r) -&gt;
    (match match match isok l with
                 | True -&gt; isok r
                 | False -&gt; False with
           | True -&gt; ltb_tree x l
           | False -&gt; False with
     | True -&gt; gtb_tree x r
     | False -&gt; False)
  module MX = OrderedTypeFacts(X)
  type coq_R_min_elt =
  | R_min_elt_0 of tree
  | R_min_elt_1 of tree * I.t * tree * X.t * tree
  | R_min_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
     tree * elt option * coq_R_min_elt
  type coq_R_max_elt =
  | R_max_elt_0 of tree
  | R_max_elt_1 of tree * I.t * tree * X.t * tree
  | R_max_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
     tree * elt option * coq_R_max_elt
  module L = MakeListOrdering(X)
  (** val flatten_e : enumeration -&gt; elt list **)
  let rec flatten_e = function
  | End -&gt; Nil
  | More (x, t0, r) -&gt; Cons (x, (app (elements t0) (flatten_e r)))
  type coq_R_bal =
  | R_bal_0 of t * X.t * t
  | R_bal_1 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_2 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_3 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * X.t
     * tree
  | R_bal_4 of t * X.t * t
  | R_bal_5 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_6 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_7 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * X.t
     * tree
  | R_bal_8 of t * X.t * t
  type coq_R_remove_min =
  | R_remove_min_0 of tree * elt * t
  | R_remove_min_1 of tree * elt * t * I.t * tree * X.t * tree
     * (t, elt) prod * coq_R_remove_min * t * elt
  type coq_R_merge =
  | R_merge_0 of tree * tree
  | R_merge_1 of tree * tree * I.t * tree * X.t * tree
  | R_merge_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * elt
  type coq_R_concat =
  | R_concat_0 of tree * tree
  | R_concat_1 of tree * tree * I.t * tree * X.t * tree
  | R_concat_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * elt
  type coq_R_inter =
  | R_inter_0 of tree * tree
  | R_inter_1 of tree * tree * I.t * tree * X.t * tree
  | R_inter_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
  | R_inter_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
  type coq_R_diff =
  | R_diff_0 of tree * tree
  | R_diff_1 of tree * tree * I.t * tree * X.t * tree
  | R_diff_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
  | R_diff_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
  type coq_R_union =
  | R_union_0 of tree * tree
  | R_union_1 of tree * tree * I.t * tree * X.t * tree
  | R_union_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_union * tree * coq_R_union
 end
module IntMake = 
 functor (I:Int) -&gt;
 functor (X:OrderedType) -&gt;
 struct 
  module Raw = MakeRaw(I)(X)
  module E = 
   struct 
    type t = X.t
    (** val compare : t -&gt; t -&gt; comparison **)
    let compare =
      X.compare
    (** val eq_dec : t -&gt; t -&gt; sumbool **)
    let eq_dec =
      X.eq_dec
   end
  type elt = X.t
  type t_ =
    Raw.t
    (* singleton inductive, whose constructor was Mkt *)
  (** val this : t_ -&gt; Raw.t **)
  let this t0 =
    t0
  type t = t_
  (** val mem : elt -&gt; t -&gt; bool **)
  let mem x s =
    Raw.mem x (this s)
  (** val add : elt -&gt; t -&gt; t **)
  let add x s =
    Raw.add x (this s)
  (** val remove : elt -&gt; t -&gt; t **)
  let remove x s =
    Raw.remove x (this s)
  (** val singleton : elt -&gt; t **)
  let singleton x =
    Raw.singleton x
  (** val union : t -&gt; t -&gt; t **)
  let union s s&#39; =
    Raw.union (this s) (this s&#39;)
  (** val inter : t -&gt; t -&gt; t **)
  let inter s s&#39; =
    Raw.inter (this s) (this s&#39;)
  (** val diff : t -&gt; t -&gt; t **)
  let diff s s&#39; =
    Raw.diff (this s) (this s&#39;)
  (** val equal : t -&gt; t -&gt; bool **)
  let equal s s&#39; =
    Raw.equal (this s) (this s&#39;)
  (** val subset : t -&gt; t -&gt; bool **)
  let subset s s&#39; =
    Raw.subset (this s) (this s&#39;)
  (** val empty : t **)
  let empty =
    Raw.empty
  (** val is_empty : t -&gt; bool **)
  let is_empty s =
    Raw.is_empty (this s)
  (** val elements : t -&gt; elt list **)
  let elements s =
    Raw.elements (this s)
  (** val choose : t -&gt; elt option **)
  let choose s =
    Raw.choose (this s)
  (** val fold : (elt -&gt; &#39;a1 -&gt; &#39;a1) -&gt; t -&gt; &#39;a1 -&gt; &#39;a1 **)
  let fold f s =
    Raw.fold f (this s)
  (** val cardinal : t -&gt; nat **)
  let cardinal s =
    Raw.cardinal (this s)
  (** val filter : (elt -&gt; bool) -&gt; t -&gt; t **)
  let filter f s =
    Raw.filter f (this s)
  (** val for_all : (elt -&gt; bool) -&gt; t -&gt; bool **)
  let for_all f s =
    Raw.for_all f (this s)
  (** val exists_ : (elt -&gt; bool) -&gt; t -&gt; bool **)
  let exists_ f s =
    Raw.exists_ f (this s)
  (** val partition : (elt -&gt; bool) -&gt; t -&gt; (t, t) prod **)
  let partition f s =
    let p = Raw.partition f (this s) in Pair ((fst p), (snd p))
  (** val eq_dec : t -&gt; t -&gt; sumbool **)
  let eq_dec s s&#39; =
    let b = Raw.equal s s&#39; in
    (match b with
     | True -&gt; Left
     | False -&gt; Right)
  (** val compare : t -&gt; t -&gt; comparison **)
  let compare s s&#39; =
    Raw.compare (this s) (this s&#39;)
  (** val min_elt : t -&gt; elt option **)
  let min_elt s =
    Raw.min_elt (this s)
  (** val max_elt : t -&gt; elt option **)
  let max_elt s =
    Raw.max_elt (this s)
 end
module Coq_IntMake = 
 functor (I:Int) -&gt;
 functor (X:Coq_OrderedType) -&gt;
 struct 
  module X&#39; = Update_OT(X)
  module MSet = IntMake(I)(X&#39;)
  type elt = X.t
  type t = MSet.t
  (** val empty : t **)
  let empty =
    MSet.empty
  (** val is_empty : t -&gt; bool **)
  let is_empty =
    MSet.is_empty
  (** val mem : elt -&gt; t -&gt; bool **)
  let mem =
    MSet.mem
  (** val add : elt -&gt; t -&gt; t **)
  let add =
    MSet.add
  (** val singleton : elt -&gt; t **)
  let singleton =
    MSet.singleton
  (** val remove : elt -&gt; t -&gt; t **)
  let remove =
    MSet.remove
  (** val union : t -&gt; t -&gt; t **)
  let union =
    MSet.union
  (** val inter : t -&gt; t -&gt; t **)
  let inter =
    MSet.inter
  (** val diff : t -&gt; t -&gt; t **)
  let diff =
    MSet.diff
  (** val eq_dec : t -&gt; t -&gt; sumbool **)
  let eq_dec =
    MSet.eq_dec
  (** val equal : t -&gt; t -&gt; bool **)
  let equal =
    MSet.equal
  (** val subset : t -&gt; t -&gt; bool **)
  let subset =
    MSet.subset
  (** val fold : (elt -&gt; &#39;a1 -&gt; &#39;a1) -&gt; t -&gt; &#39;a1 -&gt; &#39;a1 **)
  let fold x x0 x1 =
    MSet.fold x x0 x1
  (** val for_all : (elt -&gt; bool) -&gt; t -&gt; bool **)
  let for_all =
    MSet.for_all
  (** val exists_ : (elt -&gt; bool) -&gt; t -&gt; bool **)
  let exists_ =
    MSet.exists_
  (** val filter : (elt -&gt; bool) -&gt; t -&gt; t **)
  let filter =
    MSet.filter
  (** val partition : (elt -&gt; bool) -&gt; t -&gt; (t, t) prod **)
  let partition =
    MSet.partition
  (** val cardinal : t -&gt; nat **)
  let cardinal =
    MSet.cardinal
  (** val elements : t -&gt; elt list **)
  let elements =
    MSet.elements
  (** val choose : t -&gt; elt option **)
  let choose =
    MSet.choose
  module MF = 
   struct 
    (** val eqb : X.t -&gt; X.t -&gt; bool **)
    let eqb x y =
      match MSet.E.eq_dec x y with
      | Left -&gt; True
      | Right -&gt; False
   end
  (** val min_elt : t -&gt; elt option **)
  let min_elt =
    MSet.min_elt
  (** val max_elt : t -&gt; elt option **)
  let max_elt =
    MSet.max_elt
  (** val compare : t -&gt; t -&gt; t compare0 **)
  let compare s s&#39; =
    let c = compSpec2Type s s&#39; (MSet.compare s s&#39;) in
    (match c with
     | CompEqT -&gt; EQ
     | CompLtT -&gt; LT
     | CompGtT -&gt; GT)
  module E = 
   struct 
    type t = X.t
    (** val compare : t -&gt; t -&gt; t compare0 **)
    let compare =
      X.compare
    (** val eq_dec : t -&gt; t -&gt; sumbool **)
    let eq_dec =
      X.eq_dec
   end
 end
module Make = 
 functor (X:Coq_OrderedType) -&gt;
 Coq_IntMake(Z_as_Int)(X)
module M = Make(Z_as_OT)
Inductive comparison : Set :=
    Eq : comparison | Lt : comparison | Gt : comparison
CompSpec = 
fun (A : Type) (eq lt : A -&gt; A -&gt; Prop) (x y : A) =&gt;
CompareSpec (eq x y) (lt x y) (lt y x)
     : forall A : Type,
       (A -&gt; A -&gt; Prop) -&gt; (A -&gt; A -&gt; Prop) -&gt; A -&gt; A -&gt; comparison -&gt; Prop
Argument A is implicit and maximally inserted
Argument scopes are [type_scope _ _ _ _ _]
     = (0 :: 2 :: 3 :: nil) :: (0 :: 2 :: 4 :: nil) :: nil
     : list (list M.elt)
     = 0
       :: 2
          :: 4
             :: 6
                :: 8
                   :: 10
                      :: 12
                         :: 14
                            :: 16
                               :: 18
                                  :: 20
                                     :: 22
                                        :: 24
                                           :: 26
                                              :: 28
                                                 :: 
                                                 30
                                                 :: 
                                                 32
                                                 :: 
                                                 34
                                                 :: 
                                                 36
                                                 :: 
                                                 38
                                                 :: 
                                                 40
                                                 :: 
                                                 42
                                                 :: 
                                                 44
                                                 :: 
                                                 46
                                                 :: 
                                                 48
                                                 :: 
                                                 50
                                                 :: 
                                                 52
                                                 :: 
                                                 54
                                                 :: 
                                                 56
                                                 :: 
                                                 58
                                                 :: 
                                                 60
                                                 :: 
                                                 62
                                                 :: 
                                                 64
                                                 :: 
                                                 66
                                                 :: 
                                                 68
                                                 :: 
                                                 70
                                                 :: 
                                                 72
                                                 :: 
                                                 74
                                                 :: 
                                                 76
                                                 :: 
                                                 78
                                                 :: 
                                                 80
                                                 :: 
                                                 82
                                                 :: 
                                                 84
                                                 :: 
                                                 86
                                                 :: 
                                                 88 :: 
                                                 90 :: 92 :: 94 :: ..
     : list Z
     = true
     : bool
     = 0 :: 2 :: nil
     : list M.elt
     = 0 :: 2 :: 3 :: 4 :: nil
     : list M.elt
     = Lt
     : comparison
     = {|
       M.this := M.Raw.Node 2 (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                   (M.Raw.Node 1 M.Raw.Leaf 3 M.Raw.Leaf);
       M.is_ok := M.Raw.add_ok
                    (s:=M.Raw.Node 2 (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                          M.Raw.Leaf) 3
                    (M.Raw.add_ok (s:=M.Raw.Node 1 M.Raw.Leaf 2 M.Raw.Leaf) 0
                       (M.Raw.add_ok (s:=M.Raw.Leaf) 2 M.Raw.empty_ok)) |}
     : M.t
     = {|
       M.this := M.Raw.Node 2 M.Raw.Leaf 0
                   (M.Raw.Node 1 M.Raw.Leaf 2 M.Raw.Leaf);
       M.is_ok := M.Raw.inter_ok
                    (s1:=M.Raw.Node 2 (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf)
                           2 (M.Raw.Node 1 M.Raw.Leaf 3 M.Raw.Leaf))
                    (s2:=M.Raw.Node 3
                           (M.Raw.Node 2
                              (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                              M.Raw.Leaf) 4 M.Raw.Leaf)
                    (M.Raw.add_ok
                       (s:=M.Raw.Node 2
                             (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                             M.Raw.Leaf) 3
                       (M.Raw.add_ok
                          (s:=M.Raw.Node 1 M.Raw.Leaf 2 M.Raw.Leaf) 0
                          (M.Raw.add_ok (s:=M.Raw.Leaf) 2 M.Raw.empty_ok)))
                    (M.Raw.add_ok
                       (s:=M.Raw.Node 2
                             (M.Raw.Node 1 M.Raw.Leaf 2 M.Raw.Leaf) 4
                             M.Raw.Leaf) 0
                       (M.Raw.add_ok
                          (s:=M.Raw.Node 1 M.Raw.Leaf 4 M.Raw.Leaf) 2
                          (M.Raw.add_ok (s:=M.Raw.Leaf) 4 M.Raw.empty_ok))) |}
     : M.t
     = {|
       M.this := M.Raw.Node 3 (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                   (M.Raw.Node 2 (M.Raw.Node 1 M.Raw.Leaf 3 M.Raw.Leaf) 4
                      M.Raw.Leaf);
       M.is_ok := M.Raw.union_ok
                    (s1:=M.Raw.Node 2 (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf)
                           2 (M.Raw.Node 1 M.Raw.Leaf 3 M.Raw.Leaf))
                    (s2:=M.Raw.Node 3
                           (M.Raw.Node 2
                              (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                              M.Raw.Leaf) 4 M.Raw.Leaf)
                    (M.Raw.add_ok
                       (s:=M.Raw.Node 2
                             (M.Raw.Node 1 M.Raw.Leaf 0 M.Raw.Leaf) 2
                             M.Raw.Leaf) 3
                       (M.Raw.add_ok
                          (s:=M.Raw.Node 1 M.Raw.Leaf 2 M.Raw.Leaf) 0
                          (M.Raw.add_ok (s:=M.Raw.Leaf) 2 M.Raw.empty_ok)))
                    (M.Raw.add_ok
                       (s:=M.Raw.Node 2
                             (M.Raw.Node 1 M.Raw.Leaf 2 M.Raw.Leaf) 4
                             M.Raw.Leaf) 0
                       (M.Raw.add_ok
                          (s:=M.Raw.Node 1 M.Raw.Leaf 4 M.Raw.Leaf) 2
                          (M.Raw.add_ok (s:=M.Raw.Leaf) 4 M.Raw.empty_ok))) |}
     : M.t
     = 0
       :: 2
          :: 4
             :: 6
                :: 8
                   :: 10
                      :: 12
                         :: 14
                            :: 16
                               :: 18
                                  :: 20
                                     :: 22
                                        :: 24
                                           :: 26
                                              :: 28
                                                 :: 
                                                 30
                                                 :: 
                                                 32
                                                 :: 
                                                 34
                                                 :: 
                                                 36
                                                 :: 
                                                 38
                                                 :: 
                                                 40
                                                 :: 
                                                 42
                                                 :: 
                                                 44
                                                 :: 
                                                 46
                                                 :: 
                                                 48
                                                 :: 
                                                 50
                                                 :: 
                                                 52
                                                 :: 
                                                 54
                                                 :: 
                                                 56
                                                 :: 
                                                 58
                                                 :: 
                                                 60
                                                 :: 
                                                 62
                                                 :: 
                                                 64
                                                 :: 
                                                 66
                                                 :: 
                                                 68
                                                 :: 
                                                 70
                                                 :: 
                                                 72
                                                 :: 
                                                 74
                                                 :: 
                                                 76
                                                 :: 
                                                 78
                                                 :: 
                                                 80
                                                 :: 
                                                 82
                                                 :: 
                                                 84
                                                 :: 
                                                 86
                                                 :: 
                                                 88 :: 
                                                 90 :: 92 :: 94 :: ..
     : list Z
Warning: Extraction inside an opened module is experimental.
In case of problem, close it first.
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.036063u,0.s)
     = 0
       :: 2
          :: 3
             :: 4
                :: 6
                   :: 8
                      :: 9
                         :: 10
                            :: 12
                               :: 14
                                  :: 15
                                     :: 16
                                        :: 18
                                           :: 20
                                              :: 21
                                                 :: 
                                                 22
                                                 :: 
                                                 24
                                                 :: 
                                                 26
                                                 :: 
                                                 27
                                                 :: 
                                                 28
                                                 :: 
                                                 30
                                                 :: 
                                                 32
                                                 :: 
                                                 33
                                                 :: 
                                                 34
                                                 :: 
                                                 36
                                                 :: 
                                                 38
                                                 :: 
                                                 39
                                                 :: 
                                                 40
                                                 :: 
                                                 42
                                                 :: 
                                                 44
                                                 :: 
                                                 45
                                                 :: 
                                                 46
                                                 :: 
                                                 48
                                                 :: 
                                                 50
                                                 :: 
                                                 51
                                                 :: 
                                                 52
                                                 :: 
                                                 54
                                                 :: 
                                                 56
                                                 :: 
                                                 57
                                                 :: 
                                                 58
                                                 :: 
                                                 60
                                                 :: 
                                                 62
                                                 :: 
                                                 63
                                                 :: 
                                                 64
                                                 :: 
                                                 66 :: 
                                                 68 :: 69 :: 70 :: ..
     : list M.elt
Finished transaction in 0. secs (0.039269u,0.s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.304623u,0.s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.029068u,0.s)
Warning: The extraction is currently set to bypass opacity,
the following opaque constant bodies have been accessed :
 Z_as_OT.eq_dec.
type __ = Obj.t
let __ = let rec f _ = Obj.repr f in Obj.repr f
type bool =
| True
| False
(** val negb : bool -&gt; bool **)
let negb = function
| True -&gt; False
| False -&gt; True
type nat =
| O
| S of nat
type (&#39;a, &#39;b) prod =
| Pair of &#39;a * &#39;b
(** val fst : (&#39;a1, &#39;a2) prod -&gt; &#39;a1 **)
let fst = function
| Pair (x, y) -&gt; x
(** val snd : (&#39;a1, &#39;a2) prod -&gt; &#39;a2 **)
let snd = function
| Pair (x, y) -&gt; y
type comparison =
| Eq
| Lt
| Gt
(** val compOpp : comparison -&gt; comparison **)
let compOpp = function
| Eq -&gt; Eq
| Lt -&gt; Gt
| Gt -&gt; Lt
type compareSpecT =
| CompEqT
| CompLtT
| CompGtT
(** val compareSpec2Type : comparison -&gt; compareSpecT **)
let compareSpec2Type = function
| Eq -&gt; CompEqT
| Lt -&gt; CompLtT
| Gt -&gt; CompGtT
type &#39;a compSpecT = compareSpecT
(** val compSpec2Type : &#39;a1 -&gt; &#39;a1 -&gt; comparison -&gt; &#39;a1 compSpecT **)
let compSpec2Type x y c =
  compareSpec2Type c
type &#39;a sig0 =
  &#39;a
  (* singleton inductive, whose constructor was exist *)
type sumbool =
| Left
| Right
type &#39;a sumor =
| Inleft of &#39;a
| Inright
(** val plus : nat -&gt; nat -&gt; nat **)
let rec plus n0 m =
  match n0 with
  | O -&gt; m
  | S p -&gt; S (plus p m)
(** val nat_iter : nat -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
let rec nat_iter n0 f x =
  match n0 with
  | O -&gt; x
  | S n&#39; -&gt; f (nat_iter n&#39; f x)
type reflect =
| ReflectT
| ReflectF
(** val iff_reflect : bool -&gt; reflect **)
let iff_reflect = function
| True -&gt; ReflectT
| False -&gt; ReflectF
type positive =
| XI of positive
| XO of positive
| XH
type n =
| N0
| Npos of positive
type z =
| Z0
| Zpos of positive
| Zneg of positive
module Pos = 
 struct 
  type t = positive
  (** val succ : positive -&gt; positive **)
  let rec succ = function
  | XI p -&gt; XO (succ p)
  | XO p -&gt; XI p
  | XH -&gt; XO XH
  (** val add : positive -&gt; positive -&gt; positive **)
  let rec add x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XI (add p q)
       | XO q -&gt; XO (add p q)
       | XH -&gt; XI p)
    | XH -&gt;
      (match y with
       | XI q -&gt; XO (succ q)
       | XO q -&gt; XI q
       | XH -&gt; XO XH)
  (** val add_carry : positive -&gt; positive -&gt; positive **)
  and add_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XI (add_carry p q)
       | XO q -&gt; XO (add_carry p q)
       | XH -&gt; XI (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XH -&gt;
      (match y with
       | XI q -&gt; XI (succ q)
       | XO q -&gt; XO (succ q)
       | XH -&gt; XI XH)
  (** val pred_double : positive -&gt; positive **)
  let rec pred_double = function
  | XI p -&gt; XI (XO p)
  | XO p -&gt; XI (pred_double p)
  | XH -&gt; XH
  (** val pred : positive -&gt; positive **)
  let pred = function
  | XI p -&gt; XO p
  | XO p -&gt; pred_double p
  | XH -&gt; XH
  (** val pred_N : positive -&gt; n **)
  let pred_N = function
  | XI p -&gt; Npos (XO p)
  | XO p -&gt; Npos (pred_double p)
  | XH -&gt; N0
  type mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  (** val mask_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rect f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val mask_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rec f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val succ_double_mask : mask -&gt; mask **)
  let succ_double_mask = function
  | IsNul -&gt; IsPos XH
  | IsPos p -&gt; IsPos (XI p)
  | IsNeg -&gt; IsNeg
  (** val double_mask : mask -&gt; mask **)
  let double_mask = function
  | IsPos p -&gt; IsPos (XO p)
  | x0 -&gt; x0
  (** val double_pred_mask : positive -&gt; mask **)
  let double_pred_mask = function
  | XI p -&gt; IsPos (XO (XO p))
  | XO p -&gt; IsPos (XO (pred_double p))
  | XH -&gt; IsNul
  (** val pred_mask : mask -&gt; mask **)
  let pred_mask = function
  | IsPos q -&gt;
    (match q with
     | XH -&gt; IsNul
     | _ -&gt; IsPos (pred q))
  | _ -&gt; IsNeg
  (** val sub_mask : positive -&gt; positive -&gt; mask **)
  let rec sub_mask x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask p q)
       | XO q -&gt; succ_double_mask (sub_mask p q)
       | XH -&gt; IsPos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XH -&gt;
      (match y with
       | XH -&gt; IsNul
       | _ -&gt; IsNeg)
  (** val sub_mask_carry : positive -&gt; positive -&gt; mask **)
  and sub_mask_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask_carry p q)
       | XO q -&gt; succ_double_mask (sub_mask_carry p q)
       | XH -&gt; double_pred_mask p)
    | XH -&gt; IsNeg
  (** val sub : positive -&gt; positive -&gt; positive **)
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -&gt; z0
    | _ -&gt; XH
  (** val mul : positive -&gt; positive -&gt; positive **)
  let rec mul x y =
    match x with
    | XI p -&gt; add y (XO (mul p y))
    | XO p -&gt; XO (mul p y)
    | XH -&gt; y
  (** val iter : positive -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter n0 f x =
    match n0 with
    | XI n&#39; -&gt; f (iter n&#39; f (iter n&#39; f x))
    | XO n&#39; -&gt; iter n&#39; f (iter n&#39; f x)
    | XH -&gt; f x
  (** val pow : positive -&gt; positive -&gt; positive **)
  let pow x y =
    iter y (mul x) XH
  (** val square : positive -&gt; positive **)
  let rec square = function
  | XI p0 -&gt; XI (XO (add (square p0) p0))
  | XO p0 -&gt; XO (XO (square p0))
  | XH -&gt; XH
  (** val div2 : positive -&gt; positive **)
  let div2 = function
  | XI p0 -&gt; p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val div2_up : positive -&gt; positive **)
  let div2_up = function
  | XI p0 -&gt; succ p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val size_nat : positive -&gt; nat **)
  let rec size_nat = function
  | XI p0 -&gt; S (size_nat p0)
  | XO p0 -&gt; S (size_nat p0)
  | XH -&gt; S O
  (** val size : positive -&gt; positive **)
  let rec size = function
  | XI p0 -&gt; succ (size p0)
  | XO p0 -&gt; succ (size p0)
  | XH -&gt; XH
  (** val compare_cont : positive -&gt; positive -&gt; comparison -&gt; comparison **)
  let rec compare_cont x y r =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q r
       | XO q -&gt; compare_cont p q Gt
       | XH -&gt; Gt)
    | XO p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q Lt
       | XO q -&gt; compare_cont p q r
       | XH -&gt; Gt)
    | XH -&gt;
      (match y with
       | XH -&gt; r
       | _ -&gt; Lt)
  (** val compare : positive -&gt; positive -&gt; comparison **)
  let compare x y =
    compare_cont x y Eq
  (** val min : positive -&gt; positive -&gt; positive **)
  let min p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p&#39;
    | _ -&gt; p
  (** val max : positive -&gt; positive -&gt; positive **)
  let max p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p
    | _ -&gt; p&#39;
  (** val eqb : positive -&gt; positive -&gt; bool **)
  let rec eqb p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XO p0 -&gt;
      (match q with
       | XO q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XH -&gt;
      (match q with
       | XH -&gt; True
       | _ -&gt; False)
  (** val leb : positive -&gt; positive -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : positive -&gt; positive -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val sqrtrem_step :
      (positive -&gt; positive) -&gt; (positive -&gt; positive) -&gt; (positive, mask)
      prod -&gt; (positive, mask) prod **)
  let sqrtrem_step f g = function
  | Pair (s, y) -&gt;
    (match y with
     | IsPos r -&gt;
       let s&#39; = XI (XO s) in
       let r&#39; = g (f r) in
       (match leb s&#39; r&#39; with
        | True -&gt; Pair ((XI s), (sub_mask r&#39; s&#39;))
        | False -&gt; Pair ((XO s), (IsPos r&#39;)))
     | _ -&gt; Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  (** val sqrtrem : positive -&gt; (positive, mask) prod **)
  let rec sqrtrem = function
  | XI p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XI x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XI x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos (XO XH))))
  | XO p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XO x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XO x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos XH)))
  | XH -&gt; Pair (XH, IsNul)
  (** val sqrt : positive -&gt; positive **)
  let sqrt p =
    fst (sqrtrem p)
  (** val gcdn : nat -&gt; positive -&gt; positive -&gt; positive **)
  let rec gcdn n0 a b =
    match n0 with
    | O -&gt; XH
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; a
             | Lt -&gt; gcdn n1 (sub b&#39; a&#39;) a
             | Gt -&gt; gcdn n1 (sub a&#39; b&#39;) b)
          | XO b0 -&gt; gcdn n1 a b0
          | XH -&gt; XH)
       | XO a0 -&gt;
         (match b with
          | XI p -&gt; gcdn n1 a0 b
          | XO b0 -&gt; XO (gcdn n1 a0 b0)
          | XH -&gt; XH)
       | XH -&gt; XH)
  (** val gcd : positive -&gt; positive -&gt; positive **)
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  (** val ggcdn :
      nat -&gt; positive -&gt; positive -&gt; (positive, (positive, positive) prod)
      prod **)
  let rec ggcdn n0 a b =
    match n0 with
    | O -&gt; Pair (XH, (Pair (a, b)))
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; Pair (a, (Pair (XH, XH)))
             | Lt -&gt;
               let Pair (g, p) = ggcdn n1 (sub b&#39; a&#39;) a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt -&gt;
               let Pair (g, p) = ggcdn n1 (sub a&#39; b&#39;) b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 -&gt;
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XO a0 -&gt;
         (match b with
          | XI p -&gt;
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -&gt; let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XH -&gt; Pair (XH, (Pair (XH, b))))
  (** val ggcd :
      positive -&gt; positive -&gt; (positive, (positive, positive) prod) prod **)
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  (** val coq_Nsucc_double : n -&gt; n **)
  let coq_Nsucc_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val coq_Ndouble : n -&gt; n **)
  let coq_Ndouble = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val coq_lor : positive -&gt; positive -&gt; positive **)
  let rec coq_lor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XI (coq_lor p0 q0)
       | XH -&gt; p)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XO (coq_lor p0 q0)
       | XH -&gt; XI p0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; XI q0
       | _ -&gt; q)
  (** val coq_land : positive -&gt; positive -&gt; n **)
  let rec coq_land p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; Npos XH)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; N0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; N0
       | _ -&gt; Npos XH)
  (** val ldiff : positive -&gt; positive -&gt; n **)
  let rec ldiff p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (ldiff p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XH -&gt; Npos p)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; Npos XH
       | _ -&gt; N0)
  (** val coq_lxor : positive -&gt; positive -&gt; n **)
  let rec coq_lxor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XH -&gt; Npos (XI p0))
    | XH -&gt;
      (match q with
       | XI q0 -&gt; Npos (XO q0)
       | XO q0 -&gt; Npos (XI q0)
       | XH -&gt; N0)
  (** val shiftl_nat : positive -&gt; nat -&gt; positive **)
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -&gt; XO x) p
  (** val shiftr_nat : positive -&gt; nat -&gt; positive **)
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  (** val shiftl : positive -&gt; n -&gt; positive **)
  let shiftl p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 (fun x -&gt; XO x) p
  (** val shiftr : positive -&gt; n -&gt; positive **)
  let shiftr p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 div2 p
  (** val testbit_nat : positive -&gt; nat -&gt; bool **)
  let rec testbit_nat p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | O -&gt; True
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XO p0 -&gt;
      (match n0 with
       | O -&gt; False
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XH -&gt;
      (match n0 with
       | O -&gt; True
       | S n1 -&gt; False)
  (** val testbit : positive -&gt; n -&gt; bool **)
  let rec testbit p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XO p0 -&gt;
      (match n0 with
       | N0 -&gt; False
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XH -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos p0 -&gt; False)
  (** val iter_op : (&#39;a1 -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter_op op p a =
    match p with
    | XI p0 -&gt; op a (iter_op op p0 (op a a))
    | XO p0 -&gt; iter_op op p0 (op a a)
    | XH -&gt; a
  (** val to_nat : positive -&gt; nat **)
  let to_nat x =
    iter_op plus x (S O)
  (** val of_nat : nat -&gt; positive **)
  let rec of_nat = function
  | O -&gt; XH
  | S x -&gt;
    (match x with
     | O -&gt; XH
     | S n1 -&gt; succ (of_nat x))
  (** val of_succ_nat : nat -&gt; positive **)
  let rec of_succ_nat = function
  | O -&gt; XH
  | S x -&gt; succ (of_succ_nat x)
 end
module Coq_Pos = 
 struct 
  type t = positive
  (** val succ : positive -&gt; positive **)
  let rec succ = function
  | XI p -&gt; XO (succ p)
  | XO p -&gt; XI p
  | XH -&gt; XO XH
  (** val add : positive -&gt; positive -&gt; positive **)
  let rec add x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XI (add p q)
       | XO q -&gt; XO (add p q)
       | XH -&gt; XI p)
    | XH -&gt;
      (match y with
       | XI q -&gt; XO (succ q)
       | XO q -&gt; XI q
       | XH -&gt; XO XH)
  (** val add_carry : positive -&gt; positive -&gt; positive **)
  and add_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; XI (add_carry p q)
       | XO q -&gt; XO (add_carry p q)
       | XH -&gt; XI (succ p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; XO (add_carry p q)
       | XO q -&gt; XI (add p q)
       | XH -&gt; XO (succ p))
    | XH -&gt;
      (match y with
       | XI q -&gt; XI (succ q)
       | XO q -&gt; XO (succ q)
       | XH -&gt; XI XH)
  (** val pred_double : positive -&gt; positive **)
  let rec pred_double = function
  | XI p -&gt; XI (XO p)
  | XO p -&gt; XI (pred_double p)
  | XH -&gt; XH
  (** val pred : positive -&gt; positive **)
  let pred = function
  | XI p -&gt; XO p
  | XO p -&gt; pred_double p
  | XH -&gt; XH
  (** val pred_N : positive -&gt; n **)
  let pred_N = function
  | XI p -&gt; Npos (XO p)
  | XO p -&gt; Npos (pred_double p)
  | XH -&gt; N0
  type mask = Pos.mask =
  | IsNul
  | IsPos of positive
  | IsNeg
  (** val mask_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rect f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val mask_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1) -&gt; &#39;a1 -&gt; mask -&gt; &#39;a1 **)
  let mask_rec f f0 f1 = function
  | IsNul -&gt; f
  | IsPos x -&gt; f0 x
  | IsNeg -&gt; f1
  (** val succ_double_mask : mask -&gt; mask **)
  let succ_double_mask = function
  | IsNul -&gt; IsPos XH
  | IsPos p -&gt; IsPos (XI p)
  | IsNeg -&gt; IsNeg
  (** val double_mask : mask -&gt; mask **)
  let double_mask = function
  | IsPos p -&gt; IsPos (XO p)
  | x0 -&gt; x0
  (** val double_pred_mask : positive -&gt; mask **)
  let double_pred_mask = function
  | XI p -&gt; IsPos (XO (XO p))
  | XO p -&gt; IsPos (XO (pred_double p))
  | XH -&gt; IsNul
  (** val pred_mask : mask -&gt; mask **)
  let pred_mask = function
  | IsPos q -&gt;
    (match q with
     | XH -&gt; IsNul
     | _ -&gt; IsPos (pred q))
  | _ -&gt; IsNeg
  (** val sub_mask : positive -&gt; positive -&gt; mask **)
  let rec sub_mask x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask p q)
       | XO q -&gt; succ_double_mask (sub_mask p q)
       | XH -&gt; IsPos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XH -&gt;
      (match y with
       | XH -&gt; IsNul
       | _ -&gt; IsNeg)
  (** val sub_mask_carry : positive -&gt; positive -&gt; mask **)
  and sub_mask_carry x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; succ_double_mask (sub_mask_carry p q)
       | XO q -&gt; double_mask (sub_mask p q)
       | XH -&gt; IsPos (pred_double p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; double_mask (sub_mask_carry p q)
       | XO q -&gt; succ_double_mask (sub_mask_carry p q)
       | XH -&gt; double_pred_mask p)
    | XH -&gt; IsNeg
  (** val sub : positive -&gt; positive -&gt; positive **)
  let sub x y =
    match sub_mask x y with
    | IsPos z0 -&gt; z0
    | _ -&gt; XH
  (** val mul : positive -&gt; positive -&gt; positive **)
  let rec mul x y =
    match x with
    | XI p -&gt; add y (XO (mul p y))
    | XO p -&gt; XO (mul p y)
    | XH -&gt; y
  (** val iter : positive -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter n0 f x =
    match n0 with
    | XI n&#39; -&gt; f (iter n&#39; f (iter n&#39; f x))
    | XO n&#39; -&gt; iter n&#39; f (iter n&#39; f x)
    | XH -&gt; f x
  (** val pow : positive -&gt; positive -&gt; positive **)
  let pow x y =
    iter y (mul x) XH
  (** val square : positive -&gt; positive **)
  let rec square = function
  | XI p0 -&gt; XI (XO (add (square p0) p0))
  | XO p0 -&gt; XO (XO (square p0))
  | XH -&gt; XH
  (** val div2 : positive -&gt; positive **)
  let div2 = function
  | XI p0 -&gt; p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val div2_up : positive -&gt; positive **)
  let div2_up = function
  | XI p0 -&gt; succ p0
  | XO p0 -&gt; p0
  | XH -&gt; XH
  (** val size_nat : positive -&gt; nat **)
  let rec size_nat = function
  | XI p0 -&gt; S (size_nat p0)
  | XO p0 -&gt; S (size_nat p0)
  | XH -&gt; S O
  (** val size : positive -&gt; positive **)
  let rec size = function
  | XI p0 -&gt; succ (size p0)
  | XO p0 -&gt; succ (size p0)
  | XH -&gt; XH
  (** val compare_cont : positive -&gt; positive -&gt; comparison -&gt; comparison **)
  let rec compare_cont x y r =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q r
       | XO q -&gt; compare_cont p q Gt
       | XH -&gt; Gt)
    | XO p -&gt;
      (match y with
       | XI q -&gt; compare_cont p q Lt
       | XO q -&gt; compare_cont p q r
       | XH -&gt; Gt)
    | XH -&gt;
      (match y with
       | XH -&gt; r
       | _ -&gt; Lt)
  (** val compare : positive -&gt; positive -&gt; comparison **)
  let compare x y =
    compare_cont x y Eq
  (** val min : positive -&gt; positive -&gt; positive **)
  let min p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p&#39;
    | _ -&gt; p
  (** val max : positive -&gt; positive -&gt; positive **)
  let max p p&#39; =
    match compare p p&#39; with
    | Gt -&gt; p
    | _ -&gt; p&#39;
  (** val eqb : positive -&gt; positive -&gt; bool **)
  let rec eqb p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XO p0 -&gt;
      (match q with
       | XO q0 -&gt; eqb p0 q0
       | _ -&gt; False)
    | XH -&gt;
      (match q with
       | XH -&gt; True
       | _ -&gt; False)
  (** val leb : positive -&gt; positive -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : positive -&gt; positive -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val sqrtrem_step :
      (positive -&gt; positive) -&gt; (positive -&gt; positive) -&gt; (positive, mask)
      prod -&gt; (positive, mask) prod **)
  let sqrtrem_step f g = function
  | Pair (s, y) -&gt;
    (match y with
     | IsPos r -&gt;
       let s&#39; = XI (XO s) in
       let r&#39; = g (f r) in
       (match leb s&#39; r&#39; with
        | True -&gt; Pair ((XI s), (sub_mask r&#39; s&#39;))
        | False -&gt; Pair ((XO s), (IsPos r&#39;)))
     | _ -&gt; Pair ((XO s), (sub_mask (g (f XH)) (XO (XO XH)))))
  (** val sqrtrem : positive -&gt; (positive, mask) prod **)
  let rec sqrtrem = function
  | XI p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XI x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XI x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos (XO XH))))
  | XO p0 -&gt;
    (match p0 with
     | XI p1 -&gt; sqrtrem_step (fun x -&gt; XI x) (fun x -&gt; XO x) (sqrtrem p1)
     | XO p1 -&gt; sqrtrem_step (fun x -&gt; XO x) (fun x -&gt; XO x) (sqrtrem p1)
     | XH -&gt; Pair (XH, (IsPos XH)))
  | XH -&gt; Pair (XH, IsNul)
  (** val sqrt : positive -&gt; positive **)
  let sqrt p =
    fst (sqrtrem p)
  (** val gcdn : nat -&gt; positive -&gt; positive -&gt; positive **)
  let rec gcdn n0 a b =
    match n0 with
    | O -&gt; XH
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; a
             | Lt -&gt; gcdn n1 (sub b&#39; a&#39;) a
             | Gt -&gt; gcdn n1 (sub a&#39; b&#39;) b)
          | XO b0 -&gt; gcdn n1 a b0
          | XH -&gt; XH)
       | XO a0 -&gt;
         (match b with
          | XI p -&gt; gcdn n1 a0 b
          | XO b0 -&gt; XO (gcdn n1 a0 b0)
          | XH -&gt; XH)
       | XH -&gt; XH)
  (** val gcd : positive -&gt; positive -&gt; positive **)
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  (** val ggcdn :
      nat -&gt; positive -&gt; positive -&gt; (positive, (positive, positive) prod)
      prod **)
  let rec ggcdn n0 a b =
    match n0 with
    | O -&gt; Pair (XH, (Pair (a, b)))
    | S n1 -&gt;
      (match a with
       | XI a&#39; -&gt;
         (match b with
          | XI b&#39; -&gt;
            (match compare a&#39; b&#39; with
             | Eq -&gt; Pair (a, (Pair (XH, XH)))
             | Lt -&gt;
               let Pair (g, p) = ggcdn n1 (sub b&#39; a&#39;) a in
               let Pair (ba, aa) = p in
               Pair (g, (Pair (aa, (add aa (XO ba)))))
             | Gt -&gt;
               let Pair (g, p) = ggcdn n1 (sub a&#39; b&#39;) b in
               let Pair (ab, bb) = p in
               Pair (g, (Pair ((add bb (XO ab)), bb))))
          | XO b0 -&gt;
            let Pair (g, p) = ggcdn n1 a b0 in
            let Pair (aa, bb) = p in Pair (g, (Pair (aa, (XO bb))))
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XO a0 -&gt;
         (match b with
          | XI p -&gt;
            let Pair (g, p0) = ggcdn n1 a0 b in
            let Pair (aa, bb) = p0 in Pair (g, (Pair ((XO aa), bb)))
          | XO b0 -&gt; let Pair (g, p) = ggcdn n1 a0 b0 in Pair ((XO g), p)
          | XH -&gt; Pair (XH, (Pair (a, XH))))
       | XH -&gt; Pair (XH, (Pair (XH, b))))
  (** val ggcd :
      positive -&gt; positive -&gt; (positive, (positive, positive) prod) prod **)
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  (** val coq_Nsucc_double : n -&gt; n **)
  let coq_Nsucc_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val coq_Ndouble : n -&gt; n **)
  let coq_Ndouble = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val coq_lor : positive -&gt; positive -&gt; positive **)
  let rec coq_lor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XI (coq_lor p0 q0)
       | XH -&gt; p)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; XI (coq_lor p0 q0)
       | XO q0 -&gt; XO (coq_lor p0 q0)
       | XH -&gt; XI p0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; XI q0
       | _ -&gt; q)
  (** val coq_land : positive -&gt; positive -&gt; n **)
  let rec coq_land p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; Npos XH)
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_land p0 q0)
       | XH -&gt; N0)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; N0
       | _ -&gt; Npos XH)
  (** val ldiff : positive -&gt; positive -&gt; n **)
  let rec ldiff p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (ldiff p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XO q0 -&gt; coq_Ndouble (ldiff p0 q0)
       | XH -&gt; Npos p)
    | XH -&gt;
      (match q with
       | XO q0 -&gt; Npos XH
       | _ -&gt; N0)
  (** val coq_lxor : positive -&gt; positive -&gt; n **)
  let rec coq_lxor p q =
    match p with
    | XI p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XH -&gt; Npos (XO p0))
    | XO p0 -&gt;
      (match q with
       | XI q0 -&gt; coq_Nsucc_double (coq_lxor p0 q0)
       | XO q0 -&gt; coq_Ndouble (coq_lxor p0 q0)
       | XH -&gt; Npos (XI p0))
    | XH -&gt;
      (match q with
       | XI q0 -&gt; Npos (XO q0)
       | XO q0 -&gt; Npos (XI q0)
       | XH -&gt; N0)
  (** val shiftl_nat : positive -&gt; nat -&gt; positive **)
  let shiftl_nat p n0 =
    nat_iter n0 (fun x -&gt; XO x) p
  (** val shiftr_nat : positive -&gt; nat -&gt; positive **)
  let shiftr_nat p n0 =
    nat_iter n0 div2 p
  (** val shiftl : positive -&gt; n -&gt; positive **)
  let shiftl p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 (fun x -&gt; XO x) p
  (** val shiftr : positive -&gt; n -&gt; positive **)
  let shiftr p = function
  | N0 -&gt; p
  | Npos n1 -&gt; iter n1 div2 p
  (** val testbit_nat : positive -&gt; nat -&gt; bool **)
  let rec testbit_nat p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | O -&gt; True
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XO p0 -&gt;
      (match n0 with
       | O -&gt; False
       | S n&#39; -&gt; testbit_nat p0 n&#39;)
    | XH -&gt;
      (match n0 with
       | O -&gt; True
       | S n1 -&gt; False)
  (** val testbit : positive -&gt; n -&gt; bool **)
  let rec testbit p n0 =
    match p with
    | XI p0 -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XO p0 -&gt;
      (match n0 with
       | N0 -&gt; False
       | Npos n1 -&gt; testbit p0 (pred_N n1))
    | XH -&gt;
      (match n0 with
       | N0 -&gt; True
       | Npos p0 -&gt; False)
  (** val iter_op : (&#39;a1 -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 **)
  let rec iter_op op p a =
    match p with
    | XI p0 -&gt; op a (iter_op op p0 (op a a))
    | XO p0 -&gt; iter_op op p0 (op a a)
    | XH -&gt; a
  (** val to_nat : positive -&gt; nat **)
  let to_nat x =
    iter_op plus x (S O)
  (** val of_nat : nat -&gt; positive **)
  let rec of_nat = function
  | O -&gt; XH
  | S x -&gt;
    (match x with
     | O -&gt; XH
     | S n1 -&gt; succ (of_nat x))
  (** val of_succ_nat : nat -&gt; positive **)
  let rec of_succ_nat = function
  | O -&gt; XH
  | S x -&gt; succ (of_succ_nat x)
  (** val eq_dec : positive -&gt; positive -&gt; sumbool **)
  let rec eq_dec p y0 =
    match p with
    | XI p0 -&gt;
      (match y0 with
       | XI p1 -&gt; eq_dec p0 p1
       | _ -&gt; Right)
    | XO p0 -&gt;
      (match y0 with
       | XO p1 -&gt; eq_dec p0 p1
       | _ -&gt; Right)
    | XH -&gt;
      (match y0 with
       | XH -&gt; Left
       | _ -&gt; Right)
  (** val peano_rect : &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 **)
  let rec peano_rect a f p =
    let f2 = peano_rect (f XH a) (fun p0 x -&gt; f (succ (XO p0)) (f (XO p0) x))
    in
    (match p with
     | XI q -&gt; f (XO q) (f2 q)
     | XO q -&gt; f2 q
     | XH -&gt; a)
  (** val peano_rec : &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; &#39;a1 **)
  let peano_rec =
    peano_rect
  type coq_PeanoView =
  | PeanoOne
  | PeanoSucc of positive * coq_PeanoView
  (** val coq_PeanoView_rect :
      &#39;a1 -&gt; (positive -&gt; coq_PeanoView -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt;
      coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_rect f f0 p = function
  | PeanoOne -&gt; f
  | PeanoSucc (p1, p2) -&gt; f0 p1 p2 (coq_PeanoView_rect f f0 p1 p2)
  (** val coq_PeanoView_rec :
      &#39;a1 -&gt; (positive -&gt; coq_PeanoView -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt;
      coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_rec f f0 p = function
  | PeanoOne -&gt; f
  | PeanoSucc (p1, p2) -&gt; f0 p1 p2 (coq_PeanoView_rec f f0 p1 p2)
  (** val peanoView_xO : positive -&gt; coq_PeanoView -&gt; coq_PeanoView **)
  let rec peanoView_xO p = function
  | PeanoOne -&gt; PeanoSucc (XH, PeanoOne)
  | PeanoSucc (p0, q0) -&gt;
    PeanoSucc ((succ (XO p0)), (PeanoSucc ((XO p0), (peanoView_xO p0 q0))))
  (** val peanoView_xI : positive -&gt; coq_PeanoView -&gt; coq_PeanoView **)
  let rec peanoView_xI p = function
  | PeanoOne -&gt; PeanoSucc ((succ XH), (PeanoSucc (XH, PeanoOne)))
  | PeanoSucc (p0, q0) -&gt;
    PeanoSucc ((succ (XI p0)), (PeanoSucc ((XI p0), (peanoView_xI p0 q0))))
  (** val peanoView : positive -&gt; coq_PeanoView **)
  let rec peanoView = function
  | XI p0 -&gt; peanoView_xI p0 (peanoView p0)
  | XO p0 -&gt; peanoView_xO p0 (peanoView p0)
  | XH -&gt; PeanoOne
  (** val coq_PeanoView_iter :
      &#39;a1 -&gt; (positive -&gt; &#39;a1 -&gt; &#39;a1) -&gt; positive -&gt; coq_PeanoView -&gt; &#39;a1 **)
  let rec coq_PeanoView_iter a f p = function
  | PeanoOne -&gt; a
  | PeanoSucc (p0, q0) -&gt; f p0 (coq_PeanoView_iter a f p0 q0)
  (** val eqb_spec : positive -&gt; positive -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val switch_Eq : comparison -&gt; comparison -&gt; comparison **)
  let switch_Eq c = function
  | Eq -&gt; c
  | x -&gt; x
  (** val mask2cmp : mask -&gt; comparison **)
  let mask2cmp = function
  | IsNul -&gt; Eq
  | IsPos p0 -&gt; Gt
  | IsNeg -&gt; Lt
  (** val leb_spec0 : positive -&gt; positive -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : positive -&gt; positive -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : positive -&gt; positive -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        positive -&gt; positive -&gt; (positive -&gt; positive -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt;
        &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : positive -&gt; positive -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong :
      positive -&gt; positive -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : positive -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : positive -&gt; positive -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong :
      positive -&gt; positive -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : positive -&gt; positive -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : positive -&gt; positive -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module N = 
 struct 
  type t = n
  (** val zero : n **)
  let zero =
    N0
  (** val one : n **)
  let one =
    Npos XH
  (** val two : n **)
  let two =
    Npos (XO XH)
  (** val succ_double : n -&gt; n **)
  let succ_double = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (XI p)
  (** val double : n -&gt; n **)
  let double = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (XO p)
  (** val succ : n -&gt; n **)
  let succ = function
  | N0 -&gt; Npos XH
  | Npos p -&gt; Npos (Coq_Pos.succ p)
  (** val pred : n -&gt; n **)
  let pred = function
  | N0 -&gt; N0
  | Npos p -&gt; Coq_Pos.pred_N p
  (** val succ_pos : n -&gt; positive **)
  let succ_pos = function
  | N0 -&gt; XH
  | Npos p -&gt; Coq_Pos.succ p
  (** val add : n -&gt; n -&gt; n **)
  let add n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Npos (Coq_Pos.add p q))
  (** val sub : n -&gt; n -&gt; n **)
  let sub n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos n&#39; -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos m&#39; -&gt;
         (match Coq_Pos.sub_mask n&#39; m&#39; with
          | Coq_Pos.IsPos p -&gt; Npos p
          | _ -&gt; N0))
  (** val mul : n -&gt; n -&gt; n **)
  let mul n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; N0
       | Npos q -&gt; Npos (Coq_Pos.mul p q))
  (** val compare : n -&gt; n -&gt; comparison **)
  let compare n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; Eq
       | Npos m&#39; -&gt; Lt)
    | Npos n&#39; -&gt;
      (match m with
       | N0 -&gt; Gt
       | Npos m&#39; -&gt; Coq_Pos.compare n&#39; m&#39;)
  (** val eqb : n -&gt; n -&gt; bool **)
  let rec eqb n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; True
       | Npos p -&gt; False)
    | Npos p -&gt;
      (match m with
       | N0 -&gt; False
       | Npos q -&gt; Coq_Pos.eqb p q)
  (** val leb : n -&gt; n -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : n -&gt; n -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val min : n -&gt; n -&gt; n **)
  let min n0 n&#39; =
    match compare n0 n&#39; with
    | Gt -&gt; n&#39;
    | _ -&gt; n0
  (** val max : n -&gt; n -&gt; n **)
  let max n0 n&#39; =
    match compare n0 n&#39; with
    | Gt -&gt; n0
    | _ -&gt; n&#39;
  (** val div2 : n -&gt; n **)
  let div2 = function
  | N0 -&gt; N0
  | Npos p0 -&gt;
    (match p0 with
     | XI p -&gt; Npos p
     | XO p -&gt; Npos p
     | XH -&gt; N0)
  (** val even : n -&gt; bool **)
  let even = function
  | N0 -&gt; True
  | Npos p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  (** val odd : n -&gt; bool **)
  let odd n0 =
    negb (even n0)
  (** val pow : n -&gt; n -&gt; n **)
  let pow n0 = function
  | N0 -&gt; Npos XH
  | Npos p0 -&gt;
    (match n0 with
     | N0 -&gt; N0
     | Npos q -&gt; Npos (Coq_Pos.pow q p0))
  (** val square : n -&gt; n **)
  let square = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.square p)
  (** val log2 : n -&gt; n **)
  let log2 = function
  | N0 -&gt; N0
  | Npos p0 -&gt;
    (match p0 with
     | XI p -&gt; Npos (Coq_Pos.size p)
     | XO p -&gt; Npos (Coq_Pos.size p)
     | XH -&gt; N0)
  (** val size : n -&gt; n **)
  let size = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.size p)
  (** val size_nat : n -&gt; nat **)
  let size_nat = function
  | N0 -&gt; O
  | Npos p -&gt; Coq_Pos.size_nat p
  (** val pos_div_eucl : positive -&gt; n -&gt; (n, n) prod **)
  let rec pos_div_eucl a b =
    match a with
    | XI a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = succ_double r in
      (match leb b r&#39; with
       | True -&gt; Pair ((succ_double q), (sub r&#39; b))
       | False -&gt; Pair ((double q), r&#39;))
    | XO a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = double r in
      (match leb b r&#39; with
       | True -&gt; Pair ((succ_double q), (sub r&#39; b))
       | False -&gt; Pair ((double q), r&#39;))
    | XH -&gt;
      (match b with
       | N0 -&gt; Pair (N0, (Npos XH))
       | Npos p -&gt;
         (match p with
          | XH -&gt; Pair ((Npos XH), N0)
          | _ -&gt; Pair (N0, (Npos XH))))
  (** val div_eucl : n -&gt; n -&gt; (n, n) prod **)
  let div_eucl a b =
    match a with
    | N0 -&gt; Pair (N0, N0)
    | Npos na -&gt;
      (match b with
       | N0 -&gt; Pair (N0, a)
       | Npos p -&gt; pos_div_eucl na b)
  (** val div : n -&gt; n -&gt; n **)
  let div a b =
    fst (div_eucl a b)
  (** val modulo : n -&gt; n -&gt; n **)
  let modulo a b =
    snd (div_eucl a b)
  (** val gcd : n -&gt; n -&gt; n **)
  let gcd a b =
    match a with
    | N0 -&gt; b
    | Npos p -&gt;
      (match b with
       | N0 -&gt; a
       | Npos q -&gt; Npos (Coq_Pos.gcd p q))
  (** val ggcd : n -&gt; n -&gt; (n, (n, n) prod) prod **)
  let ggcd a b =
    match a with
    | N0 -&gt; Pair (b, (Pair (N0, (Npos XH))))
    | Npos p -&gt;
      (match b with
       | N0 -&gt; Pair (a, (Pair ((Npos XH), N0)))
       | Npos q -&gt;
         let Pair (g, p0) = Coq_Pos.ggcd p q in
         let Pair (aa, bb) = p0 in
         Pair ((Npos g), (Pair ((Npos aa), (Npos bb)))))
  (** val sqrtrem : n -&gt; (n, n) prod **)
  let sqrtrem = function
  | N0 -&gt; Pair (N0, N0)
  | Npos p -&gt;
    let Pair (s, m) = Coq_Pos.sqrtrem p in
    (match m with
     | Coq_Pos.IsPos r -&gt; Pair ((Npos s), (Npos r))
     | _ -&gt; Pair ((Npos s), N0))
  (** val sqrt : n -&gt; n **)
  let sqrt = function
  | N0 -&gt; N0
  | Npos p -&gt; Npos (Coq_Pos.sqrt p)
  (** val coq_lor : n -&gt; n -&gt; n **)
  let coq_lor n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Npos (Coq_Pos.coq_lor p q))
  (** val coq_land : n -&gt; n -&gt; n **)
  let coq_land n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; N0
       | Npos q -&gt; Coq_Pos.coq_land p q)
  (** val ldiff : n -&gt; n -&gt; n **)
  let rec ldiff n0 m =
    match n0 with
    | N0 -&gt; N0
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Coq_Pos.ldiff p q)
  (** val coq_lxor : n -&gt; n -&gt; n **)
  let coq_lxor n0 m =
    match n0 with
    | N0 -&gt; m
    | Npos p -&gt;
      (match m with
       | N0 -&gt; n0
       | Npos q -&gt; Coq_Pos.coq_lxor p q)
  (** val shiftl_nat : n -&gt; nat -&gt; n **)
  let shiftl_nat a n0 =
    nat_iter n0 double a
  (** val shiftr_nat : n -&gt; nat -&gt; n **)
  let shiftr_nat a n0 =
    nat_iter n0 div2 a
  (** val shiftl : n -&gt; n -&gt; n **)
  let shiftl a n0 =
    match a with
    | N0 -&gt; N0
    | Npos a0 -&gt; Npos (Coq_Pos.shiftl a0 n0)
  (** val shiftr : n -&gt; n -&gt; n **)
  let shiftr a = function
  | N0 -&gt; a
  | Npos p -&gt; Coq_Pos.iter p div2 a
  (** val testbit_nat : n -&gt; nat -&gt; bool **)
  let testbit_nat = function
  | N0 -&gt; (fun x -&gt; False)
  | Npos p -&gt; Coq_Pos.testbit_nat p
  (** val testbit : n -&gt; n -&gt; bool **)
  let testbit a n0 =
    match a with
    | N0 -&gt; False
    | Npos p -&gt; Coq_Pos.testbit p n0
  (** val to_nat : n -&gt; nat **)
  let to_nat = function
  | N0 -&gt; O
  | Npos p -&gt; Coq_Pos.to_nat p
  (** val of_nat : nat -&gt; n **)
  let of_nat = function
  | O -&gt; N0
  | S n&#39; -&gt; Npos (Coq_Pos.of_succ_nat n&#39;)
  (** val iter : n -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let iter n0 f x =
    match n0 with
    | N0 -&gt; x
    | Npos p -&gt; Coq_Pos.iter p f x
  (** val eq_dec : n -&gt; n -&gt; sumbool **)
  let eq_dec n0 m =
    match n0 with
    | N0 -&gt;
      (match m with
       | N0 -&gt; Left
       | Npos p -&gt; Right)
    | Npos x -&gt;
      (match m with
       | N0 -&gt; Right
       | Npos p0 -&gt; Coq_Pos.eq_dec x p0)
  (** val discr : n -&gt; positive sumor **)
  let discr = function
  | N0 -&gt; Inright
  | Npos p -&gt; Inleft p
  (** val binary_rect :
      &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let binary_rect f0 f2 fS2 n0 =
    let f2&#39; = fun p -&gt; f2 (Npos p) in
    let fS2&#39; = fun p -&gt; fS2 (Npos p) in
    (match n0 with
     | N0 -&gt; f0
     | Npos p -&gt;
       let rec f = function
       | XI p1 -&gt; fS2&#39; p1 (f p1)
       | XO p1 -&gt; f2&#39; p1 (f p1)
       | XH -&gt; fS2 N0 f0
       in f p)
  (** val binary_rec :
      &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let binary_rec =
    binary_rect
  (** val peano_rect : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let peano_rect f0 f n0 =
    let f&#39; = fun p -&gt; f (Npos p) in
    (match n0 with
     | N0 -&gt; f0
     | Npos p -&gt; Coq_Pos.peano_rect (f N0 f0) f&#39; p)
  (** val peano_rec : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let peano_rec =
    peano_rect
  (** val leb_spec0 : n -&gt; n -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : n -&gt; n -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_BootStrap = 
   struct 
   end
  (** val recursion : &#39;a1 -&gt; (n -&gt; &#39;a1 -&gt; &#39;a1) -&gt; n -&gt; &#39;a1 **)
  let recursion x =
    peano_rect x
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
     end
    module Tac = 
     struct 
     end
   end
  module Private_NZPow = 
   struct 
   end
  module Private_NZSqrt = 
   struct 
   end
  (** val sqrt_up : n -&gt; n **)
  let sqrt_up a =
    match compare N0 a with
    | Lt -&gt; succ (sqrt (pred a))
    | _ -&gt; N0
  (** val log2_up : n -&gt; n **)
  let log2_up a =
    match compare (Npos XH) a with
    | Lt -&gt; succ (log2 (pred a))
    | _ -&gt; N0
  module Private_NZDiv = 
   struct 
   end
  (** val lcm : n -&gt; n -&gt; n **)
  let lcm a b =
    mul a (div b (gcd a b))
  (** val eqb_spec : n -&gt; n -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val b2n : bool -&gt; n **)
  let b2n = function
  | True -&gt; Npos XH
  | False -&gt; N0
  (** val setbit : n -&gt; n -&gt; n **)
  let setbit a n0 =
    coq_lor a (shiftl (Npos XH) n0)
  (** val clearbit : n -&gt; n -&gt; n **)
  let clearbit a n0 =
    ldiff a (shiftl (Npos XH) n0)
  (** val ones : n -&gt; n **)
  let ones n0 =
    pred (shiftl (Npos XH) n0)
  (** val lnot : n -&gt; n -&gt; n **)
  let lnot a n0 =
    coq_lxor a (ones n0)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : n -&gt; n -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        n -&gt; n -&gt; (n -&gt; n -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : n -&gt; n -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong : n -&gt; n -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : n -&gt; n -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : n -&gt; n -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong : n -&gt; n -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : n -&gt; n -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : n -&gt; n -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module Z = 
 struct 
  type t = z
  (** val zero : z **)
  let zero =
    Z0
  (** val one : z **)
  let one =
    Zpos XH
  (** val two : z **)
  let two =
    Zpos (XO XH)
  (** val double : z -&gt; z **)
  let double = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos (XO p)
  | Zneg p -&gt; Zneg (XO p)
  (** val succ_double : z -&gt; z **)
  let succ_double = function
  | Z0 -&gt; Zpos XH
  | Zpos p -&gt; Zpos (XI p)
  | Zneg p -&gt; Zneg (Coq_Pos.pred_double p)
  (** val pred_double : z -&gt; z **)
  let pred_double = function
  | Z0 -&gt; Zneg XH
  | Zpos p -&gt; Zpos (Coq_Pos.pred_double p)
  | Zneg p -&gt; Zneg (XI p)
  (** val pos_sub : positive -&gt; positive -&gt; z **)
  let rec pos_sub x y =
    match x with
    | XI p -&gt;
      (match y with
       | XI q -&gt; double (pos_sub p q)
       | XO q -&gt; succ_double (pos_sub p q)
       | XH -&gt; Zpos (XO p))
    | XO p -&gt;
      (match y with
       | XI q -&gt; pred_double (pos_sub p q)
       | XO q -&gt; double (pos_sub p q)
       | XH -&gt; Zpos (Coq_Pos.pred_double p))
    | XH -&gt;
      (match y with
       | XI q -&gt; Zneg (XO q)
       | XO q -&gt; Zneg (Coq_Pos.pred_double q)
       | XH -&gt; Z0)
  (** val add : z -&gt; z -&gt; z **)
  let add x y =
    match x with
    | Z0 -&gt; y
    | Zpos x&#39; -&gt;
      (match y with
       | Z0 -&gt; x
       | Zpos y&#39; -&gt; Zpos (Coq_Pos.add x&#39; y&#39;)
       | Zneg y&#39; -&gt; pos_sub x&#39; y&#39;)
    | Zneg x&#39; -&gt;
      (match y with
       | Z0 -&gt; x
       | Zpos y&#39; -&gt; pos_sub y&#39; x&#39;
       | Zneg y&#39; -&gt; Zneg (Coq_Pos.add x&#39; y&#39;))
  (** val opp : z -&gt; z **)
  let opp = function
  | Z0 -&gt; Z0
  | Zpos x0 -&gt; Zneg x0
  | Zneg x0 -&gt; Zpos x0
  (** val succ : z -&gt; z **)
  let succ x =
    add x (Zpos XH)
  (** val pred : z -&gt; z **)
  let pred x =
    add x (Zneg XH)
  (** val sub : z -&gt; z -&gt; z **)
  let sub m n0 =
    add m (opp n0)
  (** val mul : z -&gt; z -&gt; z **)
  let mul x y =
    match x with
    | Z0 -&gt; Z0
    | Zpos x&#39; -&gt;
      (match y with
       | Z0 -&gt; Z0
       | Zpos y&#39; -&gt; Zpos (Coq_Pos.mul x&#39; y&#39;)
       | Zneg y&#39; -&gt; Zneg (Coq_Pos.mul x&#39; y&#39;))
    | Zneg x&#39; -&gt;
      (match y with
       | Z0 -&gt; Z0
       | Zpos y&#39; -&gt; Zneg (Coq_Pos.mul x&#39; y&#39;)
       | Zneg y&#39; -&gt; Zpos (Coq_Pos.mul x&#39; y&#39;))
  (** val pow_pos : z -&gt; positive -&gt; z **)
  let pow_pos z0 n0 =
    Coq_Pos.iter n0 (mul z0) (Zpos XH)
  (** val pow : z -&gt; z -&gt; z **)
  let pow x = function
  | Z0 -&gt; Zpos XH
  | Zpos p -&gt; pow_pos x p
  | Zneg p -&gt; Z0
  (** val square : z -&gt; z **)
  let square = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos (Coq_Pos.square p)
  | Zneg p -&gt; Zpos (Coq_Pos.square p)
  (** val compare : z -&gt; z -&gt; comparison **)
  let compare x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; Eq
       | Zpos y&#39; -&gt; Lt
       | Zneg y&#39; -&gt; Gt)
    | Zpos x&#39; -&gt;
      (match y with
       | Zpos y&#39; -&gt; Coq_Pos.compare x&#39; y&#39;
       | _ -&gt; Gt)
    | Zneg x&#39; -&gt;
      (match y with
       | Zneg y&#39; -&gt; compOpp (Coq_Pos.compare x&#39; y&#39;)
       | _ -&gt; Lt)
  (** val sgn : z -&gt; z **)
  let sgn = function
  | Z0 -&gt; Z0
  | Zpos p -&gt; Zpos XH
  | Zneg p -&gt; Zneg XH
  (** val leb : z -&gt; z -&gt; bool **)
  let leb x y =
    match compare x y with
    | Gt -&gt; False
    | _ -&gt; True
  (** val ltb : z -&gt; z -&gt; bool **)
  let ltb x y =
    match compare x y with
    | Lt -&gt; True
    | _ -&gt; False
  (** val geb : z -&gt; z -&gt; bool **)
  let geb x y =
    match compare x y with
    | Lt -&gt; False
    | _ -&gt; True
  (** val gtb : z -&gt; z -&gt; bool **)
  let gtb x y =
    match compare x y with
    | Gt -&gt; True
    | _ -&gt; False
  (** val eqb : z -&gt; z -&gt; bool **)
  let rec eqb x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; True
       | _ -&gt; False)
    | Zpos p -&gt;
      (match y with
       | Zpos q -&gt; Coq_Pos.eqb p q
       | _ -&gt; False)
    | Zneg p -&gt;
      (match y with
       | Zneg q -&gt; Coq_Pos.eqb p q
       | _ -&gt; False)
  (** val max : z -&gt; z -&gt; z **)
  let max n0 m =
    match compare n0 m with
    | Lt -&gt; m
    | _ -&gt; n0
  (** val min : z -&gt; z -&gt; z **)
  let min n0 m =
    match compare n0 m with
    | Gt -&gt; m
    | _ -&gt; n0
  (** val abs : z -&gt; z **)
  let abs = function
  | Zneg p -&gt; Zpos p
  | x -&gt; x
  (** val abs_nat : z -&gt; nat **)
  let abs_nat = function
  | Z0 -&gt; O
  | Zpos p -&gt; Coq_Pos.to_nat p
  | Zneg p -&gt; Coq_Pos.to_nat p
  (** val abs_N : z -&gt; n **)
  let abs_N = function
  | Z0 -&gt; N0
  | Zpos p -&gt; Npos p
  | Zneg p -&gt; Npos p
  (** val to_nat : z -&gt; nat **)
  let to_nat = function
  | Zpos p -&gt; Coq_Pos.to_nat p
  | _ -&gt; O
  (** val to_N : z -&gt; n **)
  let to_N = function
  | Zpos p -&gt; Npos p
  | _ -&gt; N0
  (** val of_nat : nat -&gt; z **)
  let of_nat = function
  | O -&gt; Z0
  | S n1 -&gt; Zpos (Coq_Pos.of_succ_nat n1)
  (** val of_N : n -&gt; z **)
  let of_N = function
  | N0 -&gt; Z0
  | Npos p -&gt; Zpos p
  (** val to_pos : z -&gt; positive **)
  let to_pos = function
  | Zpos p -&gt; p
  | _ -&gt; XH
  (** val iter : z -&gt; (&#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 **)
  let iter n0 f x =
    match n0 with
    | Zpos p -&gt; Coq_Pos.iter p f x
    | _ -&gt; x
  (** val pos_div_eucl : positive -&gt; z -&gt; (z, z) prod **)
  let rec pos_div_eucl a b =
    match a with
    | XI a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = add (mul (Zpos (XO XH)) r) (Zpos XH) in
      (match ltb r&#39; b with
       | True -&gt; Pair ((mul (Zpos (XO XH)) q), r&#39;)
       | False -&gt; Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r&#39; b)))
    | XO a&#39; -&gt;
      let Pair (q, r) = pos_div_eucl a&#39; b in
      let r&#39; = mul (Zpos (XO XH)) r in
      (match ltb r&#39; b with
       | True -&gt; Pair ((mul (Zpos (XO XH)) q), r&#39;)
       | False -&gt; Pair ((add (mul (Zpos (XO XH)) q) (Zpos XH)), (sub r&#39; b)))
    | XH -&gt;
      (match leb (Zpos (XO XH)) b with
       | True -&gt; Pair (Z0, (Zpos XH))
       | False -&gt; Pair ((Zpos XH), Z0))
  (** val div_eucl : z -&gt; z -&gt; (z, z) prod **)
  let div_eucl a b =
    match a with
    | Z0 -&gt; Pair (Z0, Z0)
    | Zpos a&#39; -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, Z0)
       | Zpos p -&gt; pos_div_eucl a&#39; b
       | Zneg b&#39; -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; (Zpos b&#39;) in
         (match r with
          | Z0 -&gt; Pair ((opp q), Z0)
          | _ -&gt; Pair ((opp (add q (Zpos XH))), (add b r))))
    | Zneg a&#39; -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, Z0)
       | Zpos p -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; b in
         (match r with
          | Z0 -&gt; Pair ((opp q), Z0)
          | _ -&gt; Pair ((opp (add q (Zpos XH))), (sub b r)))
       | Zneg b&#39; -&gt;
         let Pair (q, r) = pos_div_eucl a&#39; (Zpos b&#39;) in Pair (q, (opp r)))
  (** val div : z -&gt; z -&gt; z **)
  let div a b =
    let Pair (q, x) = div_eucl a b in q
  (** val modulo : z -&gt; z -&gt; z **)
  let modulo a b =
    let Pair (x, r) = div_eucl a b in r
  (** val quotrem : z -&gt; z -&gt; (z, z) prod **)
  let quotrem a b =
    match a with
    | Z0 -&gt; Pair (Z0, Z0)
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, a)
       | Zpos b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (of_N r))
       | Zneg b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (of_N r)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Pair (Z0, a)
       | Zpos b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((opp (of_N q)), (opp (of_N r)))
       | Zneg b0 -&gt;
         let Pair (q, r) = N.pos_div_eucl a0 (Npos b0) in
         Pair ((of_N q), (opp (of_N r))))
  (** val quot : z -&gt; z -&gt; z **)
  let quot a b =
    fst (quotrem a b)
  (** val rem : z -&gt; z -&gt; z **)
  let rem a b =
    snd (quotrem a b)
  (** val even : z -&gt; bool **)
  let even = function
  | Z0 -&gt; True
  | Zpos p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  | Zneg p -&gt;
    (match p with
     | XO p0 -&gt; True
     | _ -&gt; False)
  (** val odd : z -&gt; bool **)
  let odd = function
  | Z0 -&gt; False
  | Zpos p -&gt;
    (match p with
     | XO p0 -&gt; False
     | _ -&gt; True)
  | Zneg p -&gt;
    (match p with
     | XO p0 -&gt; False
     | _ -&gt; True)
  (** val div2 : z -&gt; z **)
  let div2 = function
  | Z0 -&gt; Z0
  | Zpos p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zpos (Coq_Pos.div2 p))
  | Zneg p -&gt; Zneg (Coq_Pos.div2_up p)
  (** val quot2 : z -&gt; z **)
  let quot2 = function
  | Z0 -&gt; Z0
  | Zpos p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zpos (Coq_Pos.div2 p))
  | Zneg p -&gt;
    (match p with
     | XH -&gt; Z0
     | _ -&gt; Zneg (Coq_Pos.div2 p))
  (** val log2 : z -&gt; z **)
  let log2 = function
  | Zpos p0 -&gt;
    (match p0 with
     | XI p -&gt; Zpos (Coq_Pos.size p)
     | XO p -&gt; Zpos (Coq_Pos.size p)
     | XH -&gt; Z0)
  | _ -&gt; Z0
  (** val sqrtrem : z -&gt; (z, z) prod **)
  let sqrtrem = function
  | Zpos p -&gt;
    let Pair (s, m) = Coq_Pos.sqrtrem p in
    (match m with
     | Coq_Pos.IsPos r -&gt; Pair ((Zpos s), (Zpos r))
     | _ -&gt; Pair ((Zpos s), Z0))
  | _ -&gt; Pair (Z0, Z0)
  (** val sqrt : z -&gt; z **)
  let sqrt = function
  | Zpos p -&gt; Zpos (Coq_Pos.sqrt p)
  | _ -&gt; Z0
  (** val gcd : z -&gt; z -&gt; z **)
  let gcd a b =
    match a with
    | Z0 -&gt; abs b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; abs a
       | Zpos b0 -&gt; Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -&gt; Zpos (Coq_Pos.gcd a0 b0))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; abs a
       | Zpos b0 -&gt; Zpos (Coq_Pos.gcd a0 b0)
       | Zneg b0 -&gt; Zpos (Coq_Pos.gcd a0 b0))
  (** val ggcd : z -&gt; z -&gt; (z, (z, z) prod) prod **)
  let ggcd a b =
    match a with
    | Z0 -&gt; Pair ((abs b), (Pair (Z0, (sgn b))))
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zpos bb))))
       | Zneg b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zpos aa), (Zneg bb)))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Pair ((abs a), (Pair ((sgn a), Z0)))
       | Zpos b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zpos bb))))
       | Zneg b0 -&gt;
         let Pair (g, p) = Coq_Pos.ggcd a0 b0 in
         let Pair (aa, bb) = p in
         Pair ((Zpos g), (Pair ((Zneg aa), (Zneg bb)))))
  (** val testbit : z -&gt; z -&gt; bool **)
  let testbit a = function
  | Z0 -&gt; odd a
  | Zpos p -&gt;
    (match a with
     | Z0 -&gt; False
     | Zpos a0 -&gt; Coq_Pos.testbit a0 (Npos p)
     | Zneg a0 -&gt; negb (N.testbit (Coq_Pos.pred_N a0) (Npos p)))
  | Zneg p -&gt; False
  (** val shiftl : z -&gt; z -&gt; z **)
  let shiftl a = function
  | Z0 -&gt; a
  | Zpos p -&gt; Coq_Pos.iter p (mul (Zpos (XO XH))) a
  | Zneg p -&gt; Coq_Pos.iter p div2 a
  (** val shiftr : z -&gt; z -&gt; z **)
  let shiftr a n0 =
    shiftl a (opp n0)
  (** val coq_lor : z -&gt; z -&gt; z **)
  let coq_lor a b =
    match a with
    | Z0 -&gt; b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; Zpos (Coq_Pos.coq_lor a0 b0)
       | Zneg b0 -&gt; Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N b0) (Npos a0))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; Zneg (N.succ_pos (N.ldiff (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt;
         Zneg
           (N.succ_pos (N.coq_land (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  (** val coq_land : z -&gt; z -&gt; z **)
  let coq_land a b =
    match a with
    | Z0 -&gt; Z0
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; Z0
       | Zpos b0 -&gt; of_N (Coq_Pos.coq_land a0 b0)
       | Zneg b0 -&gt; of_N (N.ldiff (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; Z0
       | Zpos b0 -&gt; of_N (N.ldiff (Npos b0) (Coq_Pos.pred_N a0))
       | Zneg b0 -&gt;
         Zneg
           (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
  (** val ldiff : z -&gt; z -&gt; z **)
  let ldiff a b =
    match a with
    | Z0 -&gt; Z0
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; of_N (Coq_Pos.ldiff a0 b0)
       | Zneg b0 -&gt; of_N (N.coq_land (Npos a0) (Coq_Pos.pred_N b0)))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt;
         Zneg (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt; of_N (N.ldiff (Coq_Pos.pred_N b0) (Coq_Pos.pred_N a0)))
  (** val coq_lxor : z -&gt; z -&gt; z **)
  let coq_lxor a b =
    match a with
    | Z0 -&gt; b
    | Zpos a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt; of_N (Coq_Pos.coq_lxor a0 b0)
       | Zneg b0 -&gt;
         Zneg (N.succ_pos (N.coq_lxor (Npos a0) (Coq_Pos.pred_N b0))))
    | Zneg a0 -&gt;
      (match b with
       | Z0 -&gt; a
       | Zpos b0 -&gt;
         Zneg (N.succ_pos (N.coq_lxor (Coq_Pos.pred_N a0) (Npos b0)))
       | Zneg b0 -&gt; of_N (N.coq_lxor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0)))
  (** val eq_dec : z -&gt; z -&gt; sumbool **)
  let eq_dec x y =
    match x with
    | Z0 -&gt;
      (match y with
       | Z0 -&gt; Left
       | _ -&gt; Right)
    | Zpos x0 -&gt;
      (match y with
       | Zpos p0 -&gt; Coq_Pos.eq_dec x0 p0
       | _ -&gt; Right)
    | Zneg x0 -&gt;
      (match y with
       | Zneg p0 -&gt; Coq_Pos.eq_dec x0 p0
       | _ -&gt; Right)
  module Private_BootStrap = 
   struct 
   end
  (** val leb_spec0 : z -&gt; z -&gt; reflect **)
  let leb_spec0 x y =
    iff_reflect (leb x y)
  (** val ltb_spec0 : z -&gt; z -&gt; reflect **)
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
     end
    module Tac = 
     struct 
     end
   end
  (** val sqrt_up : z -&gt; z **)
  let sqrt_up a =
    match compare Z0 a with
    | Lt -&gt; succ (sqrt (pred a))
    | _ -&gt; Z0
  (** val log2_up : z -&gt; z **)
  let log2_up a =
    match compare (Zpos XH) a with
    | Lt -&gt; succ (log2 (pred a))
    | _ -&gt; Z0
  module Private_NZDiv = 
   struct 
   end
  module Private_Div = 
   struct 
    module Quot2Div = 
     struct 
      (** val div : z -&gt; z -&gt; z **)
      let div =
        quot
      (** val modulo : z -&gt; z -&gt; z **)
      let modulo =
        rem
     end
    module NZQuot = 
     struct 
     end
   end
  (** val lcm : z -&gt; z -&gt; z **)
  let lcm a b =
    abs (mul a (div b (gcd a b)))
  (** val eqb_spec : z -&gt; z -&gt; reflect **)
  let eqb_spec x y =
    iff_reflect (eqb x y)
  (** val b2z : bool -&gt; z **)
  let b2z = function
  | True -&gt; Zpos XH
  | False -&gt; Z0
  (** val setbit : z -&gt; z -&gt; z **)
  let setbit a n0 =
    coq_lor a (shiftl (Zpos XH) n0)
  (** val clearbit : z -&gt; z -&gt; z **)
  let clearbit a n0 =
    ldiff a (shiftl (Zpos XH) n0)
  (** val lnot : z -&gt; z **)
  let lnot a =
    pred (opp a)
  (** val ones : z -&gt; z **)
  let ones n0 =
    pred (shiftl (Zpos XH) n0)
  module Private_Tac = 
   struct 
   end
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let max_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat n0 (max n0 m) __ (hl __)
       | _ -&gt; compat m (max n0 m) __ (hr __))
    (** val max_case :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let max_case n0 m x x0 x1 =
      max_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val max_dec : z -&gt; z -&gt; sumbool **)
    let max_dec n0 m =
      max_case n0 m (fun x y _ h0 -&gt; h0) Left Right
    (** val min_case_strong :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1)
        -&gt; &#39;a1 **)
    let min_case_strong n0 m compat hl hr =
      let c = compSpec2Type n0 m (compare n0 m) in
      (match c with
       | CompGtT -&gt; compat m (min n0 m) __ (hr __)
       | _ -&gt; compat n0 (min n0 m) __ (hl __))
    (** val min_case :
        z -&gt; z -&gt; (z -&gt; z -&gt; __ -&gt; &#39;a1 -&gt; &#39;a1) -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
    let min_case n0 m x x0 x1 =
      min_case_strong n0 m x (fun _ -&gt; x0) (fun _ -&gt; x1)
    (** val min_dec : z -&gt; z -&gt; sumbool **)
    let min_dec n0 m =
      min_case n0 m (fun x y _ h0 -&gt; h0) Left Right
   end
  (** val max_case_strong : z -&gt; z -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let max_case_strong n0 m x x0 =
    Private_Dec.max_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val max_case : z -&gt; z -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let max_case n0 m x x0 =
    max_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val max_dec : z -&gt; z -&gt; sumbool **)
  let max_dec =
    Private_Dec.max_dec
  (** val min_case_strong : z -&gt; z -&gt; (__ -&gt; &#39;a1) -&gt; (__ -&gt; &#39;a1) -&gt; &#39;a1 **)
  let min_case_strong n0 m x x0 =
    Private_Dec.min_case_strong n0 m (fun x1 y _ x2 -&gt; x2) x x0
  (** val min_case : z -&gt; z -&gt; &#39;a1 -&gt; &#39;a1 -&gt; &#39;a1 **)
  let min_case n0 m x x0 =
    min_case_strong n0 m (fun _ -&gt; x) (fun _ -&gt; x0)
  (** val min_dec : z -&gt; z -&gt; sumbool **)
  let min_dec =
    Private_Dec.min_dec
 end
module Z_as_OT = 
 struct 
  type t = z
  (** val compare : z -&gt; z -&gt; comparison **)
  let compare =
    Z.compare
  (** val eq_dec : z -&gt; z -&gt; sumbool **)
  let eq_dec =
    Z.eq_dec
 end
M.add
     : M.elt -&gt; M.t -&gt; M.t
     = true
     : bool
     = 0 :: 2 :: nil
     : list M.elt
M.elements_spec1 ens3
     : forall x : M.elt, InA eq x (M.elements ens3) &lt;-&gt; M.In x ens3
M.elements_spec2 ens3
     : Sorted (fun x y : Z =&gt; (x ?= y) = Lt) (M.elements ens3)
     = {|
       M.this := Node 2 (Node 1 Leaf 0 Leaf) 2 (Node 1 Leaf 3 Leaf);
       M.is_ok := @add_ok (Node 2 (Node 1 Leaf 0 Leaf) 2 Leaf) 3
                    (@add_ok (Node 1 Leaf 2 Leaf) 0 (@add_ok Leaf 2 empty_ok)) |}
     : M.t
     = {|
       M.this := Node 2 Leaf 0 (Node 1 Leaf 2 Leaf);
       M.is_ok := @inter_ok
                    (Node 2 (Node 1 Leaf 0 Leaf) 2 (Node 1 Leaf 3 Leaf))
                    (Node 3 (Node 2 (Node 1 Leaf 0 Leaf) 2 Leaf) 4 Leaf)
                    (@add_ok (Node 2 (Node 1 Leaf 0 Leaf) 2 Leaf) 3
                       (@add_ok (Node 1 Leaf 2 Leaf) 0
                          (@add_ok Leaf 2 empty_ok)))
                    (@add_ok (Node 2 (Node 1 Leaf 2 Leaf) 4 Leaf) 0
                       (@add_ok (Node 1 Leaf 4 Leaf) 2
                          (@add_ok Leaf 4 empty_ok))) |}
     : M.t
     = R.Node 2 R.Leaf 0 (R.Node 1 R.Leaf 2 R.Leaf)
     : R.tree
     = 0 :: 2 :: nil
     : list Z
R.elements_spec2 raw3 raw3_ok
     : Sorted (fun x y : Z =&gt; (x ?= y) = Lt) (R.elements raw3)
     = R.Node 3 (R.Node 1 R.Leaf 0 R.Leaf) 2
         (R.Node 2 (R.Node 1 R.Leaf 3 R.Leaf) 4 R.Leaf)
     : R.tree
     = (0 :: 2 :: 3 :: nil) :: (0 :: 2 :: 4 :: nil) :: nil
     : list (list M.elt)
     = 0
       :: 2
          :: 4
             :: 6
                :: 8
                   :: 10
                      :: 12
                         :: 14
                            :: 16
                               :: 18
                                  :: 20
                                     :: 22
                                        :: 24
                                           :: 26
                                              :: 28
                                                 :: 
                                                 30
                                                 :: 
                                                 32
                                                 :: 
                                                 34
                                                 :: 
                                                 36
                                                 :: 
                                                 38
                                                 :: 
                                                 40
                                                 :: 
                                                 42
                                                 :: 
                                                 44
                                                 :: 
                                                 46
                                                 :: 
                                                 48
                                                 :: 
                                                 50
                                                 :: 
                                                 52
                                                 :: 
                                                 54
                                                 :: 
                                                 56
                                                 :: 
                                                 58
                                                 :: 
                                                 60
                                                 :: 
                                                 62
                                                 :: 
                                                 64
                                                 :: 
                                                 66
                                                 :: 
                                                 68
                                                 :: 
                                                 70
                                                 :: 
                                                 72
                                                 :: 
                                                 74
                                                 :: 
                                                 76
                                                 :: 
                                                 78
                                                 :: 
                                                 80
                                                 :: 
                                                 82
                                                 :: 
                                                 84
                                                 :: 
                                                 86
                                                 :: 
                                                 88 :: 
                                                 90 :: 92 :: 94 :: ..
     : list Z
     = 10000%nat
     : nat
Finished transaction in 1. secs (0.647261u,0.006913s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.419275u,0.s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.041502u,0.s)
     = 10000%nat
     : nat
Finished transaction in 0. secs (0.716118u,0.s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 1. secs (1.195898u,0.s)
     = 3334%nat
     : nat
Finished transaction in 0. secs (0.075504u,0.s)
     = 16666%nat
     : nat
Finished transaction in 1. secs (0.186934u,0.s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 1. secs (0.252107u,0.s)
MF.add_iff
     : forall (s : M.t) (x y : M.elt),
       M.In y (M.add x s) &lt;-&gt; x = y \/ M.In y s
MF.add_b
     : forall (s : M.t) (x y : M.elt),
       M.mem y (M.add x s) = MF.eqb x y || M.mem y s
MP.union_inter_1
     : forall s s&#39; s&#39;&#39; : M.t,
       M.Equal (M.inter (M.union s s&#39;) s&#39;&#39;)
         (M.union (M.inter s s&#39;&#39;) (M.inter s&#39; s&#39;&#39;))
MP.set_induction
     : forall P : M.t -&gt; Type,
       (forall s : M.t, M.Empty s -&gt; P s) -&gt;
       (forall s s&#39; : M.t,
        P s -&gt; forall x : M.elt, ~ M.In x s -&gt; MP.Add x s s&#39; -&gt; P s&#39;) -&gt;
       forall s : M.t, P s
MP.fold_add
     : forall (A : Type) (eqA : A -&gt; A -&gt; Prop),
       Equivalence eqA -&gt;
       forall f : M.elt -&gt; A -&gt; A,
       compat_op Logic.eq eqA f -&gt;
       transpose eqA f -&gt;
       forall (i : A) (s : M.t) (x : M.elt),
       ~ M.In x s -&gt; eqA (M.fold f (M.add x s) i) (f x (M.fold f s i))
MP.union_inter_cardinal
     : forall s s&#39; : M.t,
       (M.cardinal (M.union s s&#39;) + M.cardinal (M.inter s s&#39;))%nat =
       (M.cardinal s + M.cardinal s&#39;)%nat
     = 20000%nat
     : nat
Finished transaction in 0. secs (0.268791u,0.003091s)
F.add
     : forall elt : Type, F.key -&gt; elt -&gt; F.t elt -&gt; F.t elt
     = Some (0 :: nil)
     : option (list Z)
     = true
     : bool
     = F.Raw.Node (F.Raw.Leaf nat) 1 1%nat
         (F.Raw.Node (F.Raw.Node (F.Raw.Leaf nat) 2 2%nat (F.Raw.Leaf nat) 1)
            3 0%nat (F.Raw.Leaf nat) 2) 3
     : F.Raw.tree nat
     = (1, 1%nat) :: (2, 2%nat) :: (3, 0%nat) :: nil
     : list (F.key * nat)
F.map2
     : forall elt elt&#39; elt&#39;&#39; : Type,
       (option elt -&gt; option elt&#39; -&gt; option elt&#39;&#39;) -&gt;
       F.t elt -&gt; F.t elt&#39; -&gt; F.t elt&#39;&#39;
F.equal
     : forall elt : Type, (elt -&gt; elt -&gt; bool) -&gt; F.t elt -&gt; F.t elt -&gt; bool
Inductive tree : Type :=
    Leaf : R.tree | Node : Int.Z_as_Int.t -&gt; R.tree -&gt; Z -&gt; R.tree -&gt; R.tree
For Node: Argument scopes are [Int_scope _ Z_scope _]
     = Z
     : Set
     = 2 :: 3 :: 1 :: nil
     : list W.elt
&quot;coqc&quot;  -q  -R . FSets   MultiSets
&quot;coqc&quot;  -q  -R . FSets   FMapListEq
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 2. secs (1.6244u,0.005876s)
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.280093u,0.s)
MF.add_1
     : forall (s : M.t) (x y : M.elt), x = y -&gt; M.In y (M.add x s)
MF.add_iff
     : forall (s : M.t) (x y : M.elt),
       M.In y (M.add x s) &lt;-&gt; x = y \/ M.In y s
MF.add_b
     : forall (s : M.t) (x y : M.elt),
       M.mem y (M.add x s) = MF.eqb x y || M.mem y s
MP.union_inter_1
     : forall s s&#39; s&#39;&#39; : M.t,
       M.Equal (M.inter (M.union s s&#39;) s&#39;&#39;)
         (M.union (M.inter s s&#39;&#39;) (M.inter s&#39; s&#39;&#39;))
MP.set_induction
     : forall P : M.t -&gt; Type,
       (forall s : M.t, M.Empty s -&gt; P s) -&gt;
       (forall s s&#39; : M.t,
        P s -&gt; forall x : M.elt, ~ M.In x s -&gt; MP.Add x s s&#39; -&gt; P s&#39;) -&gt;
       forall s : M.t, P s
MP.fold_add
     : forall (A : Type) (eqA : A -&gt; A -&gt; Prop),
       Equivalence eqA -&gt;
       forall f : M.elt -&gt; A -&gt; A,
       Proper (Logic.eq ==&gt; eqA ==&gt; eqA) f -&gt;
       transpose eqA f -&gt;
       forall (i : A) (s : M.t) (x : M.elt),
       ~ M.In x s -&gt; eqA (M.fold f (M.add x s) i) (f x (M.fold f s i))
MP.union_inter_cardinal
     : forall s s&#39; : M.t,
       (M.cardinal (M.union s s&#39;) + M.cardinal (M.inter s s&#39;))%nat =
       (M.cardinal s + M.cardinal s&#39;)%nat
Inductive tree : Type :=
    Leaf : R.tree | Node : Int.Z_as_Int.t -&gt; R.tree -&gt; Z -&gt; R.tree -&gt; R.tree
For Node: Argument scopes are [Int_scope _ Z_scope _]
     = Z
     : Set
     = 2 :: 3 :: 1 :: nil
     : list W.elt
&quot;coqc&quot;  -q  -R . FSets   FSetListEq
     = (1, 4%positive) :: (2, 7%positive) :: (3, 11%positive) :: nil
     : list (Ma.key * positive)
elements_Equal_eqlistA
     : forall (elt : Type) (m m&#39; : t elt),
       Equal m m&#39; -&gt;
       eqlistA (O.eqke (elt:=elt)) (elements (elt:=elt) m)
         (elements (elt:=elt) m&#39;)
&quot;coqc&quot;  -q  -R . FSets   MapFunction
&quot;coqc&quot;  -q  -R . FSets   UsualFacts
Warning: Obsolete syntax &quot;_eqn:H&quot; could be replaced by &quot;eqn:H&quot;
&quot;coqc&quot;  -q  -R . FSets   PrecedenceGraph/PrecedenceGraph
&quot;coqc&quot;  -q  -R . FSets   FSetList0
&quot;coqc&quot;  -q  -R . FSets   FSetAVL_test
     = true
     : bool
     = 0 :: 2 :: nil
     : list M.elt
     = 0 :: 2 :: 3 :: 4 :: nil
     : list M.elt
     = -1
     : Z
     = {|
       M.MSet.this := M.MSet.Raw.Node 2
                        (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0 M.MSet.Raw.Leaf)
                        2
                        (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 3 M.MSet.Raw.Leaf);
       M.MSet.is_ok := M.MSet.Raw.add_ok
                         (s:=M.MSet.Raw.Node 2
                               (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                  M.MSet.Raw.Leaf) 2 M.MSet.Raw.Leaf) 3
                         (M.MSet.Raw.add_ok
                            (s:=M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 2
                                  M.MSet.Raw.Leaf) 0
                            (M.MSet.Raw.add_ok (s:=M.MSet.Raw.Leaf) 2
                               M.MSet.Raw.empty_ok)) |}
     : M.t
     = {|
       M.MSet.this := M.MSet.Raw.Node 2 M.MSet.Raw.Leaf 0
                        (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 2 M.MSet.Raw.Leaf);
       M.MSet.is_ok := M.MSet.Raw.inter_ok
                         (s1:=M.MSet.Raw.Node 2
                                (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                   M.MSet.Raw.Leaf) 2
                                (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 3
                                   M.MSet.Raw.Leaf))
                         (s2:=M.MSet.Raw.Node 3
                                (M.MSet.Raw.Node 2
                                   (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                      M.MSet.Raw.Leaf) 2 M.MSet.Raw.Leaf) 4
                                M.MSet.Raw.Leaf)
                         (M.MSet.Raw.add_ok
                            (s:=M.MSet.Raw.Node 2
                                  (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                     M.MSet.Raw.Leaf) 2 M.MSet.Raw.Leaf) 3
                            (M.MSet.Raw.add_ok
                               (s:=M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 2
                                     M.MSet.Raw.Leaf) 0
                               (M.MSet.Raw.add_ok (s:=M.MSet.Raw.Leaf) 2
                                  M.MSet.Raw.empty_ok)))
                         (M.MSet.Raw.add_ok
                            (s:=M.MSet.Raw.Node 2
                                  (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 2
                                     M.MSet.Raw.Leaf) 4 M.MSet.Raw.Leaf) 0
                            (M.MSet.Raw.add_ok
                               (s:=M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 4
                                     M.MSet.Raw.Leaf) 2
                               (M.MSet.Raw.add_ok (s:=M.MSet.Raw.Leaf) 4
                                  M.MSet.Raw.empty_ok))) |}
     : M.t
     = {|
       M.MSet.this := M.MSet.Raw.Node 3
                        (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0 M.MSet.Raw.Leaf)
                        2
                        (M.MSet.Raw.Node 2
                           (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 3
                              M.MSet.Raw.Leaf) 4 M.MSet.Raw.Leaf);
       M.MSet.is_ok := M.MSet.Raw.union_ok
                         (s1:=M.MSet.Raw.Node 2
                                (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                   M.MSet.Raw.Leaf) 2
                                (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 3
                                   M.MSet.Raw.Leaf))
                         (s2:=M.MSet.Raw.Node 3
                                (M.MSet.Raw.Node 2
                                   (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                      M.MSet.Raw.Leaf) 2 M.MSet.Raw.Leaf) 4
                                M.MSet.Raw.Leaf)
                         (M.MSet.Raw.add_ok
                            (s:=M.MSet.Raw.Node 2
                                  (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 0
                                     M.MSet.Raw.Leaf) 2 M.MSet.Raw.Leaf) 3
                            (M.MSet.Raw.add_ok
                               (s:=M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 2
                                     M.MSet.Raw.Leaf) 0
                               (M.MSet.Raw.add_ok (s:=M.MSet.Raw.Leaf) 2
                                  M.MSet.Raw.empty_ok)))
                         (M.MSet.Raw.add_ok
                            (s:=M.MSet.Raw.Node 2
                                  (M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 2
                                     M.MSet.Raw.Leaf) 4 M.MSet.Raw.Leaf) 0
                            (M.MSet.Raw.add_ok
                               (s:=M.MSet.Raw.Node 1 M.MSet.Raw.Leaf 4
                                     M.MSet.Raw.Leaf) 2
                               (M.MSet.Raw.add_ok (s:=M.MSet.Raw.Leaf) 4
                                  M.MSet.Raw.empty_ok))) |}
     : M.t
     = 0
       :: 2
          :: 4
             :: 6
                :: 8
                   :: 10
                      :: 12
                         :: 14
                            :: 16
                               :: 18
                                  :: 20
                                     :: 22
                                        :: 24
                                           :: 26
                                              :: 28
                                                 :: 
                                                 30
                                                 :: 
                                                 32
                                                 :: 
                                                 34
                                                 :: 
                                                 36
                                                 :: 
                                                 38
                                                 :: 
                                                 40
                                                 :: 
                                                 42
                                                 :: 
                                                 44
                                                 :: 
                                                 46
                                                 :: 
                                                 48
                                                 :: 
                                                 50
                                                 :: 
                                                 52
                                                 :: 
                                                 54
                                                 :: 
                                                 56
                                                 :: 
                                                 58
                                                 :: 
                                                 60
                                                 :: 
                                                 62
                                                 :: 
                                                 64
                                                 :: 
                                                 66
                                                 :: 
                                                 68
                                                 :: 
                                                 70
                                                 :: 
                                                 72
                                                 :: 
                                                 74
                                                 :: 
                                                 76
                                                 :: 
                                                 78
                                                 :: 
                                                 80
                                                 :: 
                                                 82
                                                 :: 
                                                 84
                                                 :: 
                                                 86
                                                 :: 
                                                 88 :: 
                                                 90 :: 92 :: 94 :: ..
     : list Z
     = 0
       :: 6
          :: 12
             :: 18
                :: 24
                   :: 30
                      :: 36
                         :: 42
                            :: 48
                               :: 54
                                  :: 60
                                     :: 66
                                        :: 72
                                           :: 78
                                              :: 84
                                                 :: 
                                                 90
                                                 :: 
                                                 96
                                                 :: 
                                                 102
                                                 :: 
                                                 108
                                                 :: 
                                                 114
                                                 :: 
                                                 120
                                                 :: 
                                                 126
                                                 :: 
                                                 132
                                                 :: 
                                                 138
                                                 :: 
                                                 144
                                                 :: 
                                                 150
                                                 :: 
                                                 156
                                                 :: 
                                                 162
                                                 :: 
                                                 168
                                                 :: 
                                                 174
                                                 :: 
                                                 180
                                                 :: 
                                                 186
                                                 :: 
                                                 192
                                                 :: 
                                                 198
                                                 :: 
                                                 204
                                                 :: 
                                                 210
                                                 :: 
                                                 216
                                                 :: 
                                                 222
                                                 :: 
                                                 228
                                                 :: 
                                                 234
                                                 :: 
                                                 240
                                                 :: 
                                                 246
                                                 :: 
                                                 252
                                                 :: 
                                                 258
                                                 :: 
                                                 264
                                                 :: 
                                                 270 :: 276 :: 282 :: ..
     : list M.elt
Finished transaction in 0. secs (0.030388u,0.s)
     = 0
       :: 2
          :: 3
             :: 4
                :: 6
                   :: 8
                      :: 9
                         :: 10
                            :: 12
                               :: 14
                                  :: 15
                                     :: 16
                                        :: 18
                                           :: 20
                                              :: 21
                                                 :: 
                                                 22
                                                 :: 
                                                 24
                                                 :: 
                                                 26
                                                 :: 
                                                 27
                                                 :: 
                                                 28
                                                 :: 
                                                 30
                                                 :: 
                                                 32
                                                 :: 
                                                 33
                                                 :: 
                                                 34
                                                 :: 
                                                 36
                                                 :: 
                                                 38
                                                 :: 
                                                 39
                                                 :: 
                                                 40
                                                 :: 
                                                 42
                                                 :: 
                                                 44
                                                 :: 
                                                 45
                                                 :: 
                                                 46
                                                 :: 
                                                 48
                                                 :: 
                                                 50
                                                 :: 
                                                 51
                                                 :: 
                                                 52
                                                 :: 
                                                 54
                                                 :: 
                                                 56
                                                 :: 
                                                 57
                                                 :: 
                                                 58
                                                 :: 
                                                 60
                                                 :: 
                                                 62
                                                 :: 
                                                 63
                                                 :: 
                                                 64
                                                 :: 
                                                 66 :: 
                                                 68 :: 69 :: 70 :: ..
     : list M.elt
Finished transaction in 0. secs (0.028635u,0.s)
&quot;coqc&quot;  -q  -R . FSets   MultiSetsEq
     = 10000%nat
     : nat
Finished transaction in 1. secs (0.627681u,0.015799s)
     = 10000%nat
     : nat
Finished transaction in 0. secs (0.708408u,0.s)
     = 3334%nat
     : nat
Finished transaction in 0. secs (0.070152u,0.s)
&quot;coqc&quot;  -q  -R . FSets   PowerSet
     = 16666%nat
     : nat
Finished transaction in 0. secs (0.139481u,0.003726s)
     = 20000%nat
     : nat
Finished transaction in 1. secs (0.206438u,0.s)
&quot;coqc&quot;  -q  -R . FSets   FSetAVL_dep
&quot;coqc&quot;  -q  -R . FSets   FSetRBT
&quot;coqc&quot;  -q  -R . FSets   FSetAVL_prog
     = 1 :: 2 :: 3 :: 4 :: 5 :: 6 :: 7 :: 8 :: 9 :: 10 :: nil
     : list P.elt
     = nil
       :: (1 :: nil)
          :: (1 :: 2 :: nil)
             :: (1 :: 2 :: 3 :: nil)
                :: (1 :: 2 :: 3 :: 4 :: nil)
                   :: (1 :: 2 :: 3 :: 4 :: 5 :: nil)
                      :: (1 :: 2 :: 3 :: 5 :: nil)
                         :: (1 :: 2 :: 4 :: nil)
                            :: (1 :: 2 :: 4 :: 5 :: nil)
                               :: (1 :: 2 :: 5 :: nil)
                                  :: (1 :: 3 :: nil)
                                     :: (1 :: 3 :: 4 :: nil)
                                        :: (1 :: 3 :: 4 :: 5 :: nil)
                                           :: (1 :: 3 :: 5 :: nil)
                                              :: (1 :: 4 :: nil)
                                                 :: 
                                                 (1 :: 4 :: 5 :: nil)
                                                 :: 
                                                 (1 :: 5 :: nil)
                                                 :: 
                                                 (2 :: nil)
                                                 :: 
                                                 (2 :: 3 :: nil)
                                                 :: 
                                                 (2 :: 3 :: 4 :: nil)
                                                 :: 
                                                 (2 :: 3 :: 4 :: 5 :: nil)
                                                 :: 
                                                 (2 :: 3 :: 5 :: nil)
                                                 :: 
                                                 (2 :: 4 :: nil)
                                                 :: 
                                                 (2 :: 4 :: 5 :: nil)
                                                 :: 
                                                 (2 :: 5 :: nil)
                                                 :: 
                                                 (3 :: nil)
                                                 :: 
                                                 (3 :: 4 :: nil)
                                                 :: 
                                                 (3 :: 4 :: 5 :: nil)
                                                 :: 
                                                 (3 :: 5 :: nil)
                                                 :: 
                                                 (4 :: nil)
                                                 :: 
                                                 (4 :: 5 :: nil)
                                                 :: 
                                                 (5 :: nil) :: nil
     : list (list P.elt)
     = (1 :: 2 :: nil)
       :: (1 :: 3 :: nil)
          :: (1 :: 4 :: nil)
             :: (1 :: 5 :: nil)
                :: (2 :: 3 :: nil)
                   :: (2 :: 4 :: nil)
                      :: (2 :: 5 :: nil)
                         :: (3 :: 4 :: nil)
                            :: (3 :: 5 :: nil) :: (4 :: 5 :: nil) :: nil
     : list (list P.elt)
&quot;coqc&quot;  -q  -R . FSets   FSetAVL0
&quot;coqc&quot;  -q  -R . FSets   FSetFullAVL
&quot;coqc&quot;  -q  -R . FSets   extract
Warning: The extraction is currently set to bypass opacity,
the following opaque constant bodies have been accessed :
 Z_modulo_2 Zsplit2 add add blackify cardinal cardinal choose_aux compare
 conflict diff diff empty empty equal equal exists_ exists_ filter filter
 fold fold for_all for_all insert inter inter is_empty is_empty lbalance
 max_elt max_elt mem mem min_elt min_elt natlike_rec3 of_list of_list_aux
 of_slist partition partition rbalance remove remove remove_aux remove_min
 singleton singleton subset subset to_slist unbalanced_left unbalanced_right
 union union.
Warning: The identifier t__rect contains __ which is reserved for the extraction
Warning: The identifier t__rec contains __ which is reserved for the extraction
Warning: The extraction is currently set to bypass opacity,
the following opaque constant bodies have been accessed :
 add add_tree bal cardinal cardinal_rec2 compare compare2 compare2_aux
 compare2_rec2 compare_aux compare_rec2 concat cons create diff empty equal
 exists_ filter filter_acc fold for_all inter is_empty join max_elt mem merge
 min_elt partition partition_acc remove remove_max remove_min remove_tree
 singleton split subset union.
Warning: The identifier t__rect contains __ which is reserved for the extraction
Warning: The identifier t__rec contains __ which is reserved for the extraction
for i in MSetFullAVL.vo MSetAVL_test.vo demo_msets.vo demo.vo MultiSetsEq.vo MultiSets.vo FSetListEq.vo FMapListEq.vo PowerSet.vo MapFunction.vo UsualFacts.vo PrecedenceGraph/PrecedenceGraph.vo extract.vo FSetAVL_test.vo FSetAVL_prog.vo FSetAVL_dep.vo FSetRBT.vo FSetFullAVL.vo FSetAVL0.vo FSetList0.vo; do \
 install -d `dirname &quot;/home/bench/.opam/system/lib/coq/user-contrib&quot;/FSets/$i`; \
 install -m 0644 $i &quot;/home/bench/.opam/system/lib/coq/user-contrib&quot;/FSets/$i; \
done
Installing coq:contrib:fsets.8.4.dev.
</pre></dd>
            </dl>
            <h2>Installation size</h2>
            <p>Data not available in this bench.</p>
            <h2>Uninstall</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam remove -y coq:contrib:fsets.8.4.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>1 s</dd>
              <dt>Output</dt>
              <dd><pre>The following actions will be performed:
 - remove    coq:contrib:fsets.8.4.dev
=== 1 to remove ===
=-=- Synchronizing package archives -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[coq:contrib:fsets] Fetching git://clarus.io/fsets#v8.4
=-=- Removing Packages =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Removing coq:contrib:fsets.8.4.dev.
  rm -R /home/bench/.opam/system/lib/coq/user-contrib/FSets
</pre></dd>
              <dt>Missing removes</dt>
              <dd>
                none
              </dd>
              <dt>Wrong removes</dt>
              <dd>
                none
              </dd>
            </dl>
          </div>
        </div>
      </div>
      <hr/>
      <div class="footer">
        <p class="text-center">
          <small>Sources are on <a href="https://github.com/coq-bench">GitHub</a>. Â© Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../../../../../bootstrap.min.js"></script>
  </body>
</html>